### 1. 如何在Node.js中进行高效的日志处理
- 异步日志记录: 使用异步方式记录日志，避免阻塞线程
- 日志级别控制: 只记录重要的日志, 例如错误日志
- 日志轮转: 限制日志文件大小
- 批量日志写入: 批量写入日志，将日志积累到一定程度再写入磁盘
- 日志缓冲机制: 将日志先写入内存缓冲区，定时或达到一定大小时再写入磁盘
---
### 2. Node.js的事件循环
事件循环是一个永远运行的循环，使得Node.js能非阻塞地执行I/O操作，即使在执行其他操作时也能处理新请求
事件循环分为几个阶段:
- Timer(定时器阶段): 主要处理setTimeout()和setInterval()的回调函数
- I/O Callbacks(I/O 回调阶段): 主要处理大部分的回调
- Idle, prepare(空闲、准备阶段): 内部使用阶段，不对用户公开
- Poll(轮询阶段): 查看是否有新的I/O事件，如果有则处理，没有则休眠等待任务
- Check(检查阶段): 专门处理setImmediate()的回调函数
- Close Callbacks(关闭回调阶段): 主要处理socket的close事件
---
### 3. Node.js回调、Promise和Async/Await区别
- 回调: 最基本的异步处理方式，将一个函数作为参数传递给另一个函数，异步操作完成后调用这个回调函数
- Promise: 封装异步操作，返回一个Promise对象，通过then()方法处理异步操作的结果
- async/await: 基于Promise的语法糖，将Promise转换为同步代码，使用起来更方便。错误处理使用try...catch
---
### 4. 非阻塞I/O
- 非阻塞I/O: 在输入输出时不需要等待数据传输完毕，可以允许系统继续执行其他任务，提高系统的并发性。
---
### 5. 事件发射器
- 事件发射器: 可以创建、触发和监听事件。允许我们对异步事件进行订阅并在事件发生时执行回调函数。
- 使用:
  ```javascript
  const EventEmitter = require('events'); // 1. 引入事件发射器模块
  const emitter = new EventEmitter(); // 2. 创建事件发射器实例

  // 3. 监听事件
  emitter.on('event', (data) => { // 监听事件
    console.log('Event triggered:', data);
  })
  // 4. 触发事件
  emitter.emit('event', 'Hello, World!'); // 触发事件
  ```
---
### 6. setImmediate()和setTimeout()的区别
它们都是用来调度异步任务的定时器
区别:
1. 执行时机: setImmediate()允许当前事件循环结束后立即执行回调函数，setTimeout()允许指定延迟时间后执行回调函数
2. 优先级: setImmediate()的回调函数优先级高于setTimeout()的回调函数
3. 使用场景: setImmediate()适用于需要立即执行的任务，而setTimeout()适用于需要延迟执行的任务
---
### 7. Node.js的process.nextTick()
process.nextTick()是一个用于将回调函数插入到当前执行栈底部，它优先于队列中的所有回调函数执行。

---
### 8. Node.js的require和import的区别
二者都是用于导入模块的，但是它们有区别:
1. 模块规范: require使用CommonJS规范，import使用ES6模块规范
2. 语法: require使用`const module = require('路径');`，import()使用`import 模块名 from '路径';`
3. 执行时机: require是同步加载模块并立即执行，import是异步加载模块
4. 支持范围: require在Node.js中原生支持，import需要使用Babel等编译器支持才能在node.js中使用
  ---
### 9. Node.js的process对象及其常用属性
process对象提供了有关node.js的进程信息和控制，任何地方都可直接使用
常用属性:
- process.argv: 获取命令行参数
- process.env: 获取环境变量
- process.exit(): 退出进程
- process.cwd(): 获取当前进程工作目录
- process.memoryUsage(): 获取进程内存使用情况
- process.uptime(): 获取进程运行时间
- process.nextTick(): 下一次事件循环中调用的回调函数
---
### 10. Node.js的模块加载
node.js使用CommonJS规范进行模块加载。使开发者将代码分成独立的文件和模块进行组织和复用。
加载过程包括路径解析，文件类型识别，编译和缓存等步骤

---
### 11. Node.js解析JSON
使用JSON.parse()方法将JSON字符串解析为JavaScript对象:
```javascript
const jsonString = '{"name": "John", "age": 30}';
const jsonObject = JSON.parse(jsonString);
console.log(jsonObject.name); // John
console.log(jsonObject.age); // 30
```
---
### 12. Node.js的Buffer对象
Buffer对象用于处理二进制数据，提供对内存缓冲区的操作能力
作用:
- 处理二进制数据: 用于读取视频、图片、文件等二进制数据
- 与流结合: 用于文件处理，网络传输
- 转换编码格式: 将不同编码格式的字符串相互转换
---
### 13. Node.js的全局对象
全局对象是node.js中内置的、可以直接访问的、无需导入的JavaScript对象。
- global: 全局命名空间对象，类似于window对象
- process: 进程对象，用于获取进程信息、控制进程等
- __dirname和__filename: 当前文件所在目录的绝对路径和当前文件绝对路径
- console: 控制台对象，用于打印日志、错误信息等
- module和exports: 模块对象，用于导出模块内容、导入模块内容
- 定时器函数: setTimeout()、setInterval()、clearTimeout()、clearInterval()
- Buffer: 用于处理二进制数据
---
### 14. package.json文件
package.json文件是node.js项目配置文件，
包含了:
- 描述项目基本信息: 名称、版本、描述等
- 依赖项: 项目依赖的模块列表
- 脚本: 项目的启动、测试、打包等脚本
- 配置项: 项目的配置项，如入口文件、仓库地址等
---
### 15. 回调函数
回调函数是一种将函数作为参数传递给另一个函数的机制，通常用于异步处理。
```javascript
const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) => { // 其中，第三个参数是回调函数
  if (err) throw err;
  console.log(data);
})
```
---
### 16. npm
npm是node.js的包管理工具，用于安装、更新、卸载和搜索javascript包和依赖。
npm管理项目依赖:
1. 初始化项目: `npm init -y` 生成package.json文件
2. 安装依赖: `npm install 包名` 安装指定包
3. 保存依赖: `npm install 包名 --save`(默认自动保存)
4. 更新依赖: `npm update 包名`
5. 卸载依赖: `npm uninstall 包名`
---
### 17. 同步和异步
同步: 这种代码会阻塞后续代码执行，直到该代码执行完毕。
异步: 这种代码不会阻塞后续代码执行，当该代码执行完毕时，会通过回调函数、Promise、async/await等机制将结果返回给调用方。

---

### 18. nodejs中创建服务器
1. 引入http模块: `const http = require('http');`
2. 创建服务器: 
   ```javascript
   const server = http.createServer((req, res) => {
     res.statusCode = 200; // 设置响应状态码
     res.setHeader('Content-Type', 'text/plain'); // 设置响应头
     res.end('Hello World\n'); // 发送响应数据
   });
   ```
3. 监听端口: 
    ```javascript
    const port = 3000;
    server.listen(port, () => {
      // 启动成功
    })
    ```
---
### 19. 登录鉴权及其优缺点
1. Session-Cookie: 用户登录后，创建一个会话(Session)并将其id存入cookie中。后续请求中，客户端携带cookie维持会话状态。
   优点: 状态管理清晰，适用于服务端渲染的web应用
   缺点: 会话信息存储在服务端，不适合分布式应用，加重服务器负担
2. Token认证(JWT): 利用JSON Web Token(JWT)加密的令牌标识用户的身份，登录成功后，服务器生成的token返回客户端，后续携带该token进行身份验证。
   优点: 减少服务器状态存储，适用于分布式应用和前后端分离应用
   缺点: Token过期失效控制较难，增加令牌保护复杂性
3. OAuth2.0: 允许用户不暴露用户名密码的情况下，使用第三方访问其受保护的资源(支付宝、微信等)，第三方账号会随着用户登录将授权信息传递到服务器完成鉴权
   优点: 避免了账户管理，方便用户
   缺点: 需要第三方授权，适用性窄
---
### 20. 页面请求接口大规模并发解决方案
1. 前端并发控制:
   请求合并: 将同类型的请求合并成一个请求
   请求队列: 实现请求排队机制，控制请求数量
   防抖节流: 对频繁触发的请求进行控制
2. 数据缓存:
   前端缓存: 利用浏览器缓存数据
   接口缓存: 合理设置Http缓存头，利用CDN缓存
3. 后端并发控制:
   数据库优化: 适当添加索引，优化查询语句
   服务端优化: 使用Redis等中间件
---
### 21. Webpack性能优化
1. 代码分割: 通过动态导入，将代码分割成多个模块，按需加载
2. 资源压缩: 使用TerserWebpackPlugin对javascript代码进行压缩，并使用css-minimizer-plugin对css进行压缩。
3. 图片优化: 使用image-webpack-loader对图片进行压缩。
4. 预加载: 使用prefetch或preload对静态资源进行预加载。
5. 缓存管理: 设置合适的缓存策略，通过hash文件名管理缓存。
6. Tree Shaking: ES6模块的静态代码分析，去除未使用的代码。
---
### 22. Webpack作用
Webpack是一个前端资源打包工具，将复杂的项目模块化管理，转化成浏览器友好的代码，提高开发效率和性能
1. 模块化: 将项目拆分成多个模块，优化代码结构加载速度
2. 按需加载: 将代码拆分，实现按需加载，减少初次加载时间
3. 资源管理: 通过各种加载器和插件，处理样式、图片、字体等
4. 开发友好: 提供热更新、实时重载等功能
---
### 23. 使用Webpack和LocalStorage实现静态资源离线缓存
结合Service Worker和LocalStorage，可以实现静态资源离线缓存。
1. 配置Webpack: 添加Service Worker配置，并设置缓存策略。
2. 使用Service Worker缓存资源: Service Worker会监听用户网络请求，将资源缓存在浏览器
3. 使用LocalStorage存储资源: LocalStorage可以存储用户配置，上次访问时间等信息。
--- 
### 24. Webpack的图片处理加载器
1. file-loader: 将图片文件复制到输出目录，返回其URL。
2. url-loader: 类似于file-loader，但可以将图片转为base64编码，嵌入javascript中。
3. image-webpack-loader: 对图片进行压缩调整大小。
4. responsive-loader: 根据屏幕宽度，生成多尺寸的图片。
---
### 25. Webpack优化产出代码
1. 代码分割: 使用splitChunks插件，将代码分割成多个模块，按需加载。
2. Tree Shaking: 使用ES6模块，去除未使用的代码。
3. 压缩和混淆: 使用TerserWebpackPlugin对javascript代码进行压缩。
4. 资源优化: 使用image-webpack-loader对图片进行压缩。
5. 开启生产模式: 通过设置mode为production启动内置优化。
---
### 26. webpack-dev-server监控文件
1. 安装webpack-dev-server
2. 在webpack.config.js中添加devServer选项
3. 在package.json的scripts中添加启动命令
---
### 27. 前端开发优化网络请求
1. 减少http请求
2. 使用缓存
3. 采用懒加载
4. 采用内容分发网络(CDN)
5. 压缩优化资源
6. 使用预加载和预取
--- 
### 28. Webpack解决跨域问题
1. 安装Webpack和WebpackDevServer
2. 在webpack.config.js中添加devServer选项，设置代理
3. 在命令行中使用`npx webpack serve`启动服务后，通过代理路径访问API
---
### 29. Webpack处理内联css
安装style-loader和css-loader配合实现，前者将CSS内联到JavaScript文件中，
后者负责解析`@import`和`url()`等语句。

---
### 30. Webpack和rollup、parcel构建工具区别
1. webpack: 兼容性好，可处理各种文件类型; 高度自定义和灵活性，根据项目需求配置各种功能; 缺点是配置很复杂，构建速度慢
2. Rollup: 适合构建JS库，对模块化的支持很好能生成轻量化代码。缺点是不适合大型页面应用
3. Parcel: 适合小项目，构建速度快，支持多种文件类型，缺点是功能简单，缺乏高级优化控制
---    
### 31. Live-Reload自动刷新和HMR热模块替换区别
二者均是自动化工具，区别:
1. live-reload: 当文件发生变化时，它会自动刷新整个页面
2. HMR: 它只会替换更新的模块，而不需要重新加载整个页面
---
### 32. 前端使用Webpack进行高效优化
1. 入口分包: 合理配置多个入口文件，为不同页面生成不同文件
2. 公共代码提取: 将公共代码提取到一个单独的包中，减少重复
3. 懒加载: 通过动态导入实现懒加载，只在需要时加载模块
4. 异步模块提取: 将异步加载的模块和同步模块区分开，异步模块单独打包
---
### 33. Webpack实现条件组件按需打包
1. 动态导入
   使用`import()`语法，在需要时动态加载模块。
2. 代码分割
   Webpack的代码分割功能，可以将应用程序分成多个包
---
### 34. Webpack Loader
1. babel-loader: 将ES6替换为向后兼容的JavaScript代码
2. ts-loader: 将TypeScript转换为JavaScript
3. css-loader: 解析CSS的`@import`和`url()`
4. style-loader: 将CSS注入到DOM的style标签中
5. sass-loader: 将Sass和Scss编译成CSS
6. file-loader: 处理文件，返回文件URL
7. url-loader: 类似于file-loader，但当文件小于设定的字节限制时，返回base64编码的Data Url
---
### 35. Webpack插件底层实现原理
1. Tapable库: Webpack使用Tapable库来管理和调度各个钩子函数，这些钩子允许在构建过程的特定时机插入逻辑
2. 插件机制: 插件通过apply方法访问Webpack生命周期钩子，并在适当位置注入自定义逻辑
---
### 36. 前端项目的缓存配置策略
1. 强缓存
2. 协商缓存
3. 按需缓存
4. 预加载
---
### 37. 优化Webpack打包后的文件体积
1. 代码拆分: 将大的源文件拆分成更小的文件按需导入
2. 使用Tree Shaking: 剔除未被使用的JavaScript代码
3. 启用压缩: 使用压缩插件对JavaScript代码和静态资源进行压缩
4. 合理设置第三方库的按需引入
5. 移除无用插件和polyfills
---
### 38. 常用前端性能分析工具
1. Chrome DevTools
2. Lighthouse
3. WebPageTest
4. GTmetrix
5. PageSpeed Insights
6. New Relic
---
### 39. 网站优化关键
1. 减少http请求: 合并CSS和JavaScript文件
2. 使用内容分发网络(CDN): 静态资源托管在CDN上
3. 优化图像: 压缩图像或使用WebP格式
4. 启用浏览器缓存
5. 代码压缩和混淆
6. 异步加载资源
7. 减少重绘和重排
8. 使用http/2
---
### 40. 前端项目中配置HTTP缓存机制
1. 使用浏览器缓存控制Http头部字段:
   - Cache-Control
   - ETag
   - Last-Modified
2. 服务器端配置缓存策略，如Nginx或Apache
   合理划分缓存策略
   配置不同资源类型的缓存时间
---
### 41. 优化Webpack打包速度
1. 合理利用缓存
2. 分割代码
3. 多进程并行压缩
4. 减少解析范围
5. 使用更快的编译器
---
### 42. Webpack处理node_modules的依赖
1. 通过enhanced-resolve解析模块路径
2. 根据package.json中的配置字段确定模块入口文件
3. 使用配置的loader处理模块内容，转化为webpack理解的JavaScript代码
---
### 43. CoreWebVitals
Core Web Vitals是谷歌提出的核心网页指标，用于衡量网站的用户体验
1. LCP: 最大内容渲染时间, 衡量加载性能, 小于2.5秒
2. INP: 交互后下一帧的绘制时间, 衡量互动性, 200ms内
3. CLS: 累计布局偏移, 衡量视觉稳定, 0.1s内
---
### 44. Webpack的bundle、chunk、module
1. module(模块): 项目中被引入的文件对于webpack都是模块
2. chunk(代码块): webpack打包过程中，一组module的集合
3. bundle(打包结果): 最终输出的一个或多个打包结果
---
### 45. 同一页面3个组件请求同一个API并发发送3次请求优化
1. 利用全局状态管理工具来管理和共享数据
2. 在父组件中请求数据，通过props传递给子组件
3. 使用请求缓存机制，将API的请求结果缓存起来
--- 
### 46. 前端项目中，如何优化首屏渲染
1. 加载优化
   - 路由懒加载
   - 资源预加载
   - 合理使用服务端渲染
2. 资源优化
   - 代码分割
   - 静态资源压缩
   - 图片优化
3. 缓存优化
   - 浏览器缓存
   - 本地缓存
4. 代码优化
   - 避免重复渲染
   - 减少主线程阻塞

---
### 47. 用户输入网址到网页显示过程
1. 浏览器解析url
2. 请求dns服务器获取ip地址
3. 建立tcp连接
4. https握手
5. 发送http请求，先封装成tcp段，再封装成ip数据包，最后在链路层封装成帧，由物理层发出
6. 服务器处理请求，返回对应数据
7. 浏览器接收到响应，渲染页面，执行js
8. 显示页面
---
### 48. 处理前端一次性返回超大属性结构数据
1. 懒加载, 点击到子节点再去渲染相应的组件
2. 虚拟滚动树形结构, 只渲染可见区域的节点
3. 缓存机制, 利用浏览器缓存已经加载的数据
4. 分页, 对于同级大量节点采用分页展示
---
### 49. 渲染10万条数据且不卡顿的解决方案
1. 虚拟滚动，只渲染可见区域的数据
2. 分页渲染，将数据分批次渲染

---

### 50. 浏览器执行100w个任务不卡顿
任务分批次处理，避免主线程阻塞
1. requestAnimationFrame: 每一帧处理一部分任务
2. setTimeout/setInterval: 通过定时器分批处理任务
3. MessageChannel: 利用微任务队列，分批次调度任务
4. requestIdleCallback: 浏览器空闲时执行任务
---
### 51. 扫码登录
1. 获取二维码
   网页端向后端请求生成唯一标识(uuid), 转换成二维码
2. 轮询二维码状态
   定时向后端轮询，查看uuid对应的扫码状态
3. 手机端扫码与授权
   微信扫一扫扫描二维码，识别uuid和回调，授权同意后，微信会回调，携带临时code
4. 后端处理授权
   后端收到回调后，用code换取access_token和openid, 与uuid绑定，写入缓存
5. 登录成功
   前端轮询发现uuid被授权，获取登录信息，跳转页面
---
### 52. 设计能够统计前端页面请求耗时的工具
核心思路是拦截和记录每一次网络请求发起和结束的时间，计算耗时
1. 全局重写XMLHttpRequest和fetch方法，在请求发起和响应时间记录时间点，计算耗时
2. 通过`performance.getEntriesByType("resource")`方法获取所有请求详细耗时
---
### 53. 设计和优化秒杀系统前端
1. 界面设计
   界面简洁明了，用户能快速理解相关功能及物品信息
2. 性能优化
   使用懒加载、CDN加速资源加载等方式优化页面性能
   按钮防抖机制，防止频繁点击发出大量请求
3. 防止刷量和攻击
   利用验证码等功能防止机器人刷量
   使用WebSocket实时获取服务器数据，避免频繁刷新页面
4. 用户体验
   秒杀时提供即时反馈，成功或失败后，提供明确的信息
---
### 54. 在无限滚动加载内容时回收上面的内容
核心思路是，指渲染可视区域附近的内容，超出可视区域的内容就从DOM中移除替换为占位元素，用户滚动时动态加载和卸载内容。
利用VirtualList组件可以做到只渲染当前可见内容和一定缓冲区的内容。

---
### 55. 前端实现断点续传，传输大文件
思路: 将大文件分割成小块，每个小块单独上传，如果网络中断，只需上传未完成的块
1. 使用File对象的slice方法，切割文件
2. 计算文件的MD5值，用于服务器校验和断点续传
3. 每个分片通过接口单独上传
4. 记录上传进度，确保断网后可恢复上传
5. 分片上传完成后，通知服务端合并文件
---
### 56. 前端基于WebSocket实现实时聊天
1. WebSocket实现实时通信
   通过WebSocket可以和后端服务器保持长连接，实时收发消息
2. 多用户在线聊天流程
   - 用户登录后，前端建立WebSocket连接，并将用户消息发送给服务器
   - 服务器维护在线用户的连接消息
   - 服务器将用户发送的消息广播给目标用户或群组
   - 前端监听WebSocket消息，收到消息后更新聊天窗口
3. 消息通知
   通过浏览器的Notification API实现消息通知
---
### 57. 解决前端SPA应用首屏加载慢
原因在于需要加载大量js和css资源
解决方案:
1. 路由使用动态导入实现懒加载
2. 异步非关键的js
3. 静态资源部署到CDN
---
### 58. 设计前端日志埋点SDK
日志埋点SDK可以帮助开发者收集用户在应用中的行为数据，性能指标和异常信息
架构组成:
1. 采集层: 负责收集各类数据
2. 处理层: 对数据进行过滤
3. 传输层: 将数据发送到服务器
4. 缓存层: 在网络不可用时临时存储数据
5. 配置层: 控制SDK行为和采样率等等
---
### 59. 禁止调试前端代码
1. 通过不断触发debugger语句阻止正常调试
2. 检测浏览器窗口的大小，打开开发者工具会改变窗口大小，超过阈值执行防御措施
3. 监测代码执行前后时间差来判断是否处于调试状态
4. 禁止常用的打开开发者工具的快捷键
5. 使用第三方库disable-devtool等
---
### 60. 单点登录及其原理
单点登录是一种用户登录方式，用户只需要登录一次，就能访问多个相关但独立的系统。
实现方式:
1. 共享Cookie, 子系统使用相同父域名，将信息存储在父域名cookie中
2. 跨域SSO-CAS模式。中央认证服务器实现跨域单点登录
3. 基于JWT的SSO，使用JSON Web Token在多个系统间传递用户信息
---
### 61. 前端页面白屏原因
1. 资源加载失败，检查浏览器开发者工具是否有异常状态码
2. Javascript异常，检查控制台是否有报错信息
3. 路由配置异常，检查路由配置文件
4. 首屏渲染问题，如果接口响应慢会使页面长时间空白
5. 服务器渲染异常，检查服务器日志
6. 样式问题，可能设置了display:none等样式导致页面空白
7. 浏览器兼容问题，可尝试切换不同浏览器
---
### 62. 当前端静态资源加载失败时，降级处理
1. 图片加载失败时，监听图片的onerror事件，将图片替换为默认图片
2. JS/CSS加载失败时，监听onerror事件，提示用户刷新
3. 配置多个CDN源地址，主源失败时负责兜底
4. 关键JS加载失败时，可以展示简化页面，确保基础信息可见
5. 通过window.onerror监听全局错误，并记录日志
--- 
### 63. 给网页添加水印，防止水印被擦除
1. 原生HTML/CSS:
   在页面上层插入div，设置pointer-events: none; 内容为水印文字 使用position: fixed; 覆盖页面
2. Canvas:
   用canvas绘制水印，将其设置为body或某个容器的背景图片，用repeat平铺。
3. 防止页面擦除
   - 监听DOM变化，用MutationObserver监控，若水印被修改，则重新添加
   - 多层水印，增加移除难度
   - 禁止pointer-events
   - 混淆class/id, 让其随机生成，防止通过选择器删除
   - 部分敏感场景可让后端生成
---
### 64. 实现主题切换
1. 在CSS中定义一套基础变量
2. 在需要切换的地方都用上该变量
3. 通过JS修改根节点的data-theme属性
4. 用localStorage保存当前主题，下次打开时读取
---
### 65. 实现页面截图
1. 使用html2canvas或DOM-to-Image，它通过遍历页面元素并在Canvas上绘制元素来生成图片
2. 简单场景可以直接使用Canvas API
---
### 66. 实现PC端访问Web应用，移动端展示H5应用
1. 通过JavaScript通过User-Agent判断访问环境
2. 通过CSS媒体查询实现响应式布局，根据屏幕宽度切换样式
3. 服务端渲染，根据请求头来判断设备类型，返回对应HTML
4. 单页应用中，可以使用前端路由高内聚设备类型渲染不同组件
---
### 67. 前端处理超过JS的Number最大值的数字
1. 只做数据展示时，直接转成字符串
2. 需要运算时，使用BigInt，或者使用第三方库big.js等
3. 和后端约定，由后端处理大数，前端仅作展示
---
### 68. 调试和解决跨浏览器兼容问题
通常是由css和js导致的
解决方案:
1. 使用can i use 检查某特性在浏览器的兼容性情况
2. 先为现代浏览器设计完整功能，在为旧浏览器设计替代方案
---
### 69. 利用节流或防抖优化频发触发请求的搜索输入框
对于搜索框，一般会使用防抖来优化。
核心思想是，等待用户停止输入一段时间后，再发起请求，避免中间状态的无效请求。
每次用户输入都会重置延迟，直到在指定时间(通常是500ms)没有新输入时，才会执行搜索请求。
节流是指限制函数在一定时间内只执行一次，适用于滚动加载或实时预览等场景

---
### 70. 网页中有大量图片时的优化加载
1. 实现图片懒加载，当图片进入视口时才加载
2. 使用WebP或AVIF格式的图片, 它们提供更好的压缩率
3. 使用`srcset`属性根据屏幕大小提供不同尺寸的图片
4. 压缩图片，减少图片大小
5. 将图片放在CDN上，利用分布式服务器加速图片加载
---
### 71. 定位前端页面发生错误的元素
1. 使用浏览器的调试工具查看报错
2. 使用try...catch语句来捕获错误
3. 在关键位置使用console.log()来记录错误信息
---
### 72. 实现第一次访问页面不触发请求，后续进入页面自动触发请求
思路: 使用sessionStorage或localStorage来记录访问状态，区分"首次加载"和"后续进入"
进入页面时，检查本地存储中是否有访问标记，没有则不发请求并设置标记
后续进入页面检查到标记存在，则发起请求

---
### 73. 对每个JavaScript函数的执行进行拦截
1. 使用高阶函数将原函数包裹一层，在执行前后插入拦截逻辑，适用于数量有限，可控场景
2. 使用Proxy可以拦截对象上的方法调用，包括函数本身。适合批量拦截
---
### 74. 判断一个点是否在Canvas的图形内
1. 使用isPointInPath(x, y)判断点(x, y)是否在Canvas的图形内部
2. 使用isPointInStroke(x, y)判断点(x, y)是否在Canvas的图形的描边区域
---
### 75. 防止用户反复提交表单
1. 当用户点击一次提交后，立刻禁用提交按钮，防止用户重复提交表单
2. 在提交时，设置一个标志，提交完成或失败后再重置
3. 提交时添加防抖操作，防止短时间内多次触发提交
4. 每次提交表单时，携带token，由后端来校验token是否用过
---
### 76. 实现国际化，根据用户设置自动切换语言
1. 选择国际化框架：vue-i18n
2. 安装必要依赖
3. 创建翻译文件
4. 设置i18next，包括默认语言、语言检测、资源加载
5. 创建切换语言组件
--- 
### 77. 实现实时自动补全搜索框
1. 监听输入框input时间，设置防抖避免频繁请求
2. 根据用户输入异步获取匹配数据
3. 动态创建和更新候选列表，支持键盘导航
4. 实现上下箭头确认和回车确认
---
### 78. Vue性能优化方案
1. 利用代码分割按需加载组件和模块
2. 利用keep-active将不需要频繁更新的组件缓存起来，避免重复渲染
3. 减少watch和computed计算的次数，减少不必要的依赖触发
4. 避免深层次的数据观察，尽量避免使用watch的keep选项
5. 使用虚拟滚动技术减少大数据量场景下的DOM渲染数量
6. 减少不必要的全局事件监听，避免频繁触发事件
---
### 79. Vuex的state/getter/mutation/action/module作用
1. state: 存储全局共享的状态
2. Getter: 类似于计算属性，用于计算并返回基于state的衍生状态
3. Mutation: 更改state的方法，是同步的
4. Action: 类似于Mutation，但用于处理异步操作
5. Module: 为了方便管理，可以把store分成多个module
---
### 80. 开发一个任务列表应用，设计思路
1. 功能设计
   - 任务增删改查
   - 任务状态管理
   - 任务分类
   - 数据持久化
2. 组件设计
   - TaskApp 根组件
   - TaskForm 任务输入列表
   - TaskList 任务列表容器
   - TaskItem 单个任务项
   - TaskFilter 任务筛选
3. 状态管理
   简单应用，可以使用props和emit进行管理
   复杂应用可以使用VueX和Pinia进行集中管理
4. 实现步骤
   - 创建项目
   - 实现基本功能
   - 实现数据持久化
   - 添加样式和交互效果
---
### 81. v-if和v-for优先级，二者同时出现的性能优化
Vue2中，v-for优先级高于v-if; Vue3中，v-if优先级高于v-for。
可以将v-if放在v-for外面，减少不必要的循环或者判断

---
### 82. 在Vue开发过程中需要同时与多人联调接口的情况
1. 建立统一的接口管理与配置
2. 后端接口未完成时，使用Mock数据进行前端开发
3. 利用Vue CLI的devServer或Vite的server.proxy配置解决跨域问题
4. 与后端团队共同指定接口规范
5. 针对不同的后端服务创建不同的开发分支
---
### 83. 解决Vue初始化页面闪动的问题
1. 在要隐藏的元素上添加v-cloak的指令
2. 在css中添加`[v-cloak] {display: none;}`
---
### 84. Vue3的设计目标以及优化
1. 更小的框架体积，减少应用加载时间
2. 提高渲染速度和影响性能
3. 完全使用TypeScript重写，更好地支持TypeScript
4. 引入组合式API, 比选项式API更灵活
--- 
### 85. Pinia和VueX的区别
1. Pinia的API比VueX的更加简洁
2. Vuex需要手动拆分模块合并，Pinia定义不同的store就能实现状态拆分
3. Pinia具有更好的TypeScript的支持，Vuex需要更多的手动配置
4. Pinia的插件生态暂时不如Vuex丰富
---
### 86. Vue3性能提升的方面
1. 更小的包体积
2. Vue3重写了虚拟DOM实现，引入了编译时优化
3. 优化了组件初始化过程，避免了不必要的选项合并
4. 从Object.defineProperty切换到Proxy，使响应式系统更高效
5. Vue3支持了多根节点组件，减少了不必要的DOM节点创建
---
### 87. 优化Webpack打包Vue的速度
1. 通过代码分割、压缩等方式减少打包后文件体积
2. 合理配置loader和plugin, 减少不必要的配置项
3. 利用CDN加载第三方库
4. 利用缓存机制，减少打包重复构建时间
5. 使用多进程提高打包效率
6. 配置`TerserWebpackPlugin`增加打包的并发数
---
### 88. Vue首页白屏原因
1. 资源加载失败
2. JS执行错误
3. 路由配置问题
4. 首屏加载慢，渲染内容多
   
解决方案:
1. 使用webpack导入功能实现按需加载
2. 将Vue、Vuex等第三方库通过CDN引入
3. 添加全局错误处理
4. 将耗时操作放入nextTick
5. 使用骨架屏或预渲染
6. 添加加载指示器
---
### 89. Vuex的实现原理
1. Central Store: 所有的状态都被集中存储在全局store对象中
2. 状态集中管理: 所有状态的修改都必须通过特定的mutation函数
3. Getter: 类似于计算属性，允许从store中派生状态
4. Actions: 可以包含异步操作，通过dispatch调用mutation，改变状态
5. Modules: vuex支持将store分割成多个模块，增加可维护性
--- 
### 90. Vuex和localStorage的区别
1. Vuex是一种管理状态模式，用于Vue中组件之间的共享状态
2. localStorage是浏览器提供的本地存储机制，用于在客户端持久化数据
--- 
### 91. 解决SPA单页应用首屏加载速度慢
1. 代码分割: 使用Webpack对代码进行分割打包，按需加载
2. 对于不需要在首屏加载的资源，可以使用懒加载，在需要时加载
3. 使用Vue的Nuxt.js框架实现服务器端渲染
4. 压缩和优化CSS、JavaScript和图片等静态资源，减少文件大小
5. 将静态资源托管到CDN，利用全球分布节点加快加载速度
6. 利用浏览器的缓存机制，减少重复请求
---
### 92. Vuex状态的缺点
1. 对于中小型应用，使用Vuex会增加不必要的复杂度和代码量
2. 使用Vuex会增加很多样板代码
3. Vuex学习路线陡峭
4. 由于有状态管理，Vuex增加了额外的运行开销
--- 
### 93. 设计一个Vue路由系统
1. 监听URL变化，有hash和history两种模式
2. 维护一份路由表，每个路由对象包含path和component
3. URL变化时，遍历路由表，找到与当前路径匹配的路由，渲染对应组件
4. 需要有一个响应式的currentRoute状态，URL变化自动更新
5. 实现router-view组件，根据currentRoute渲染对应组件
6. 实现push，replace等方法，支持编程式导航
---
### 94. 设计一款Vue的组件库
1. 分析面向的用户群体，确定组件库的风格
2. 选择合适的vue版本、确定构建工具、选择CSS预处理器, 以及typescript的使用
3. 保持API风格统一，坚持高内聚低耦合的特性
4. 建立组件开发规范，使用git进行版本控制，编写详细文档
5. 为组件编写单元测试，确保组件质量
6. 开发交互式文档网站，提供组件的使用说明和示例
---
### 95. 解决Vue打包时vendor文件过大问题
1. 通过代码拆分将大文件拆分成小文件，按需加载
2. 剔除不必要的第三方库，使用更轻量的库
3. 将体积大的库排除，改用CDN引入
4. 使用tree shaking技术，只打包实际使用的代码
5. 开启生产环境构建优化，移除调试信息，压缩代码
---
### 96. Vue2和Vue3的区别
1. 用Proxy代替Object.defineProperty, 提高了性能
2. 引入了组合式API, 解决了选项式API在大型项目的代码组织问题，便于维护
3. 新增了Teleport组件，允许将一部分DOM渲染到DOM树外的位置，便于处理弹出框
4. Vue3支持返回多个根节点，简化了组件结构
5. Vue3使用TypeScript重写，提供了更好的类型支持
6. 新增了Suspense组件，用于协调对异步依赖的处理
---
### 97. 使用Vue渲染大量数据时，如何进行优化
1. 使用虚拟滚动，加载在视口中显示的数据项，如vue-virtual-scroll-list
2. 实现懒加载，分批次渲染大量数据，如keep-alive
3. 使用事件代理可以减少内存占用，将事件监听绑到更高级的父元素
4. 合理使用监听器和计算属性，尽量少用方法，避免不必要的计算
5. 尽可能减少Vuex等全局状态管理器的滥用
---
### 98. 在Vue使用过滤器
在Vue2中:
1. 在main.js中通过Vue.filter注册全局过滤器
2. 在组件的filters选项中定义过滤器
3. 在模板插值表达式中通过管道符`|`使用

在Vue3中, 过滤器被移除
1. 过滤器增加了模板语法复杂性，不如计算属性和方法直观，也不如计算属性和方法灵活
2. 不利于TypeScript支持
--- 
### 99. Vue的slot作用
slot是Vue中的插槽，组件内的占位符，允许父组件在使用子组件时，在子组件标签中传递内容，内容会被渲染到slot位置
默认插槽，向子组件传递内容
具名插槽，多个不同位置的内容填充
作用域插槽，接收子组件传递数据的插槽

---
### 100. Vuex的mutation为什么不能异步
mutation的设计理念时用于同步地更新Vuex的状态，如果在mutation中进行异步操作会导致状态不可预测，难以追踪

---
### 101. 在Vue中实现权限管理，控制权限到按钮级别
1. 路由权限控制
   利用路由守卫，在路由跳转前(beforeEach)，判断用户是否有访问路由的权限，若没有，则重定向到指定页面。
2. 按钮权限控制
   前端通过后端返回的用户操作权限列表，判断当前用户是否有使用按钮的权限，没有则隐藏或禁用按钮。
---
### 102. Vue缓存当前组件，缓存后如何更新
使用`keep-live`组件可以使得在切换路由时保留组件状态避免重新渲染
在缓存的组件中设置一个`:key`属性，当该属性值变化，则会强制Vue重新渲染组件

---
### 103. 实现一个Vue3的弹窗组件
1. 弹窗基本包含，顶部标题，中间内容，底部按钮三部分
2. 支持自定义内容
3. 使用Teleport将弹窗渲染到body标签下，避免父组件CSS影响
4. 通过响应式ref控制弹窗显示隐藏
5. 设计多种关闭方式, 按钮关闭，点击遮罩层关闭等
---
### 104. Vue的v-cloak和v-pre作用
1. `v-cloak`用于隐藏尚未编译的Vue模板，直到Vue实例准备就绪为止。用于解决页面加载过程中出现的模板闪烁问题
2. `v-pre`用于跳过元素和它的子元素的编译过程，其中的模板语法不会经过编译
---
### 105. Vue中如何获取路由传递的参数
1. 在Vue2中，通过`this.$route.params`获取动态路由匹配参数，通过`this.$route.query`获取路由查询参数
2. 在Vue3中，通过useRoute()生成的route实例，再通过`route.params`获取动态路由匹配参数，`route.query`获取查询参数
---
### 106. 过滤器的使用场景
过滤器是一种格式化数据的功能，主要用于文本格式化、数值格式化、日期格式化、列表数据过滤
Vue3已经移除，使用计算属性或方法代替

---
### 107. Vue Router配置404页面
1. 创建一个404页面的组件
2. 在路由配置中添加通配符: (Vue router3中是`path:'*'`; Vue router4中是`path:'/:pathMatch(.*)*'`), 
3. 通配符路由要放在路由规则最后，未被匹配到的路由都会被重定向到404页面
---
### 108. Vue3实现复杂表单验证和提交逻辑
1. 使用Composition API自定义表单验证
2. 集成第三方表单库
3. 使用Element Plus等UI组件库
4. 结合TypeScript类型验证
---
### 109. Vue的template标签有什么用
1. Vue2: 作为一个占位符去使用，或者在组件中传递插槽内容，编译后被删除
2. Vue3: 同Vue2，但不使用v-if/v-else-if/v-else、v-slot、v-for的时候，Vue不会处理，会渲染成template标签
---
### 110. Vue中的data属性是一个函数而不是对象
1. data作为函数返回一个新的对象，确保每个组件都有独立的状态
2. 避免数据共享问题，保持组件的可复用性
3. 确保数据变化可预测，便于调试维护
---
### 111. 在Vue渲染模板时，保留模板中的HTML注释
1. 在Vue2中，可以在组件选项中设置`comments: true`保留注释
2. 可以在包含注释的元素上使用`v-pre`的指令，会让Vue跳过该元素及其子元素的编译
3. 在Vue3中，使用`<!-- [COMMENTS] -->`保留注释内容
---
### 112. Vue中不建议同时使用v-if和v-for
1. Vue2中，v-for优先级高，二者同时使用会导致v-if在每次迭代都会执行，引发性能问题；
   Vue3中，v-if优先级高，v-if会无法访问v-for作用域中的变量
2. 同时使用两个指令会使得逻辑变得复杂难理解，降低了可读性，提高了维护难度
---
### 113. 实现Vuex的store插件
1. 定义插件函数: 插件是一个接收store作为唯一参数的函数
2. 在Vuex创建store时，把插件传入plugins选项
---
### 114. 从零构建Vue项目
1. 使用Vue CLI或者Vite创建项目
2. 项目目录设计
   ```
   my-vue-project/
   ├── public/              # 静态资源，不需要webpack处理
   ├── src/                 # 源代码
   │   ├── assets/          # 静态资源（会被webpack处理）
   │   ├── components/      # 公共组件
   │   ├── views/           # 页面级组件
   │   ├── router/          # 路由配置
   │   ├── store/           # 状态管理
   │   ├── api/             # API请求封装
   │   ├── utils/           # 工具函数
   │   ├── styles/          # 全局样式
   │   ├── App.vue          # 根组件
   │   └── main.js          # 入口文件
   ├── .env.*               # 环境变量配置
   ├── package.json         # 项目依赖
   └── vite.config.js/vue.config.js  # 构建配置
   ```
3. 安装必要的插件和库
   - vue router
   - Pinia/Vuex
   - Axios
   - ESLint
   - UI组件库
4. 工程化配置
   - 配置路由
   - 设置状态管理
   - 封装http请求
   - 配置环境变量
   - 设置代码规范
---
### 115. Vue组件的name选项作用
1. 方便调试与开发，在Vue DevTools中，会使用name属性作为组件标识
2. 当组件需要在模板中递归引用自己时，需要name
3. 警告和错误的时候给出清晰标识
4. 配合keep-active做缓存
---
### 116. 在Vue3中使用defineAsyncComponent实现异步组件加载
1. 使用ES模块动态导入来异步加载组件
2. 选项式API中的components选项中注册，或者在组合式API中结合defineAsyncComponents导入组件路径注册
3. 不建议在路由中使用异步组件，路由已经通过动态导入处理了异步加载，再使用异步组件会增加复杂度
---
### 117. Vuex的module及其应用场景
模块化是指将Vuex的store分割成更小的可维护的模块，让store更可控和易于维护，提升代码可读性
应用场景：
1. 有多个独立子功能模块需要管理状态
2. 项目规模大时，将store拆分成多个模块
3. 团队开发时，不同人员可以专注于自己负责的模块
---
### 118. Vue的v-show和v-if区别
1. v-if的机制是DOM元素的添加或删除；
   v-show仅仅只是切换CSS的display属性控制元素的显示和隐藏
2. v-if在初始条件不成立时不会渲染元素；
   v-show无论条件如何都会渲染元素
3. v-if在切换时开销高，因为要移除或添加DOM元素
   v-show在切换时开销低，仅仅是切换display属性
4. v-if支持v-else和v-else-if, 且可以作用在template标签上
   v-show不支持v-else和v-else-if，也不能作用在template标签上
--- 
### 119. Vue计算属性函数名和data属性是否可以同名
不可以，
挂载顺序: prop > methods > data > computed > watch
Vue会将data中的属性和计算属性都挂载到Vue实例上，若同名就会命名冲突，实例中的属性就会被覆盖

---
### 120. 如何监听Vuex数据的变化
1. 使用watch可以监听Vuex state的变化
2. 使用subscribe可以监听mutation的变化
---
### 121. DIFF算法的原理
通过比较新旧两棵虚拟DOM树，并且只更新必要部分以达到高效更新真实DOM的目的，可以避免不必要的DOM操作，提升性能

---
### 122. 在Vue自定义事件中，父组件如何接收子组件传递的多个参数
1. 通过`$emit`方法传递多个参数，然后在父组件定义一个方法处理参数
2. eventBus事件总线全局范围内传递事件和数据
3. Vuex状态管理数据共享
4. 作用域插槽
--- 
### 123. 在React Router的history模式中，push和replace方法的区别
1. push方法会向浏览器的历史记录栈中添加一条新记录，当用户点击回退按钮时，可以回到之前的界面
2. replace方法会替换当前历史记录，不会新增历史记录，当用户点击浏览器回退按钮时，回到替换前的界面
---
### 124. React受控组件及其应用场景
受控组件是指表单元素的值由React state控制的组件。
表单数据由React组件处理，不由DOM处理
应用场景:
1. 即时验证输入内容的有效性
2. 根据表单提交状态动态改变按钮的禁用状态
3. 强制输入特定格式
4. 一个输入框的输入要依赖另一个输入框的值
---
### 125. React的JSX中属性覆盖原则
React中属性是可以被覆盖的
1. 后面的属性会覆盖前面的同名属性
2. 直接声明的属性会覆盖通过展开运算符传入的同名属性
---
### 126. React项目中引入图片
1. import导入, 适用于项目内的静态图片资源
2. require导入, 适用于动态导入图片
3. public文件夹, 适用于不需要打包处理的静态资源
---
### 127. render函数中能否使用if else
不能，因为render返回的是JSX，本质上是JavaScript表达式，表达式内部不能直接使用语句

---
### 128. React Router的类型
1. BrowserRouter,适用于现代浏览器
2. HashRouter,适用于旧版浏览器
3. MemoryRouter,适用于测试和非浏览器环境
---
### 129. 为什么不建议在react中遍历时使用索引作为唯一key值
当数据重新排序或者增删改查时，索引值会改变，导致不必要的渲染，或者渲染错误，通常建议使用id作为key值。

---
### 130. 除了在构造函数中绑定this, 还有哪些绑定this的方式
1. 定义方法时使用箭头函数
2. 在render中，使用箭头函数调用，同时还能传递参数
3. 使用bind方法在render中绑定this
---
### 131. 若React组件属性中没有传值，默认值是什么
默认值是undefined
初始化默认值的方法:
1. 使用函数组件时设置默认值
2. 类组件中可以使用defaultProps属性设置默认值(不推荐)
---
### 132. Redux如何实现多个组件之间的通信，多个组件使用相同状态时的管理
1. 集中管理状态: 所有的共享状态都保存在统一的store中，store是唯一数据源
2. 组件通过dispatch发送action到reducer来更新状态，更新后的状态会通过store订阅机制通知到相关组件
3. 组件通过connect或useSelector Hook来访问store中的状态
---
### 133. React为什么要用虚拟DOM提高性能
如果直接操作真实DOM是相对耗时的，虚拟DOM是一种轻量级的副本，允许React在内存中进行计算，将最小、最高效的变化应用到真正的DOM上，减少不必要的DOM更新

---
### 134. JavaScript中0.1 + 0.2 !== 0.3, 要如何处理
很多十进制小数在二进制中无法精确表示
解决方案:
1. 使用误差范围, 这个值为number.EPSILON, 表示可接受的最小误差范围
2. 使用toFixed方法, 将结果四舍五入到指定位数
3. 使用Number.toPrecision方法, 用于格式化数字精度
---
### 135. typeof和instanceof的区别
二者都是检查变量类型的关键字
区别: 
1. typeof用于检测基本数据类型、函数、未定义类型和symbol;
   instanceof用于检测对象类型, 检查某对象是否是某个构造函数的实例
2. typeof检测基本类型会返回具体的数据类型，对于对象返回object;
   instanceof只能用于引用类型，不能检测基本数据类型
---
### 136. typeof null 值是什么，为什么
typeof null 返回 object
在JavaScript中，对象的类型标识符是000，而null被任务是一个空指针，即零地址，二者相等，因此typeof null错误地被设置为object

---
### 137. JavaScript中null和undefined区别
undefined表示变量声明了，但没有赋值
null表示一个空对象引用

---
### 138. 如何判断JavaScript变量是数组
1. 使用Object.prototype.toString.call()做判断，若是数组会返回`[Object, Array]`
2. 通过原型链做判断
3. ES6新增了Array.isArray()做判断
4. 使用instanceof做判断
---
### 139. JavaScript数据类型
原始类型：
1. Undefined: 声明变量但未赋值
2. Null: 表示空值或不存在的对象
3. Boolean: true和false，用于做判断
4. Number: 表示整数或浮点数
5. String: 表示字符序列
6. Symbol: 创建唯一且不可变的值
7. BigInt: 表示任意精度大整数
   
引用类型:
Object(对象，数组，函数等)

---
### 140. JS作用域
1. 全局作用域: 定义在所有函数体和代码块之外的变量，可以在任何地方访问
2. 局部作用域: 定义在函数内或代码块内的变量，只能在函数或代码块内访问
3. 函数作用域: 只在函数内部可见的变量
4. 块作用域: 在块级代码中使用let和const声明的变量
---
### 141. let/const/var区别
作用域:
1. var在函数作用域内有效，且能够在函数外被访问
2. let和const在块级作用域内有效
   
赋值:
1. var可以被重新赋值和重新声明
2. let可以重新赋值但不能重新声明
3. const既不能重新赋值，也不能重新声明
   
提升:
1. var会被提升到作用域顶部，但不会初始化
2. let和const会被提升到作用域顶部，但初始化之前不会被访问
---
### 142. 使用let全局声明变量，能通过windows对象获取吗
不能，es6新增的声明变量类型在全局作用域声明不会被自动挂在windows对象上，var可以

---
### 143. JavaScript尾调用
指函数最后一步操作是调用另一个函数
尾调用可以复用当前函数的调用帧来降低内存消耗
严格模式下才会开启尾调用
尾调用不能引用当前函数作用域的变量
尾调用的结果就是函数返回值

---
### 144. BigInt和Number区别
1. 数值范围
   Number类型受64位双精度浮点数限制
   BigInt可以表示任意大整数
2. 数值精度
   Number小数计算可能存在精度损失
   BigInt只能表示整数，不能有小数
3. 类型标识
   Number直接用数字字面量
   BigInt数字末尾要加n，或者用BigInt()构造函数
---
### 145. JavaScript中Object.keys返回值顺序
ES6之前无序，ES6后顺序排列如下:
1. 数字属性优先返回，并按照大小升序排列
2. 非数字的字符串其次，按照被添加到对象的顺序排列
3. Symbol不会被返回，需要用到Object.getOwnPropertySymbols才能读取。
---
### 146. 对fetch的理解
用于在浏览器中发起http请求的API
优点:
1. 基于Promise实现，支持链式调用和async/await语法
2. 提供Request和Response对象
3. 支持HTTP/2流式处理，通过Response.body可以获取原始响应流

缺点:
1. 不会自动携带cookie, 需要手动设置credentials
2. 不提供终端请求方法，需借助AbortController实现
3. 不能直接获取请求进度，对于大文件上传有影响
---
### 147. ES6新特性
1. let和const
2. 箭头函数
3. 模板字符串
4. 解构赋值
5. 默认参数
6. 扩展运算符
7. 通过class定义类，使用import和export导入和导出模块
8. Promise处理异步操作
9. Symbol和迭代器
10. 新的数据结构Map、Set
---
### 148. 箭头函数能做构造函数吗
不能，因为箭头函数没有this对象，没有argument、caller、prototype属性，无法通过new关键字调用。

---
### 149. 箭头函数和普通函数的区别
1. 写法不同
2. 若只有一个参数，箭头函数可省略括号
3. 若函数只有一条语句还可以省略花括号和return
4. 箭头函数没有自己的this对象，从其作用域链的上一层继承
5. 箭头函数this指向不能通过call/apply/bind改变
6. 箭头函数不能当构造函数，不能对箭头函数使用new
7. 箭头函数没有自己的arguments对象，没有prototype
---
### 150. TypeScript对象类型
对象类型用于描述非原始类型的值，比如具有特定结构的对象、数组、函数
定义方式:
1. 匿名对象，通过类JavaScript语法定义对象
2. 类型别名，通过关键字type创建
3. 接口，通过interface关键字定义
---
### 151. TypeScript常用类型
基础类型: string、number、boolean、null、undefined、symbol、bigint
复杂类型: array、tuple、enum、object
特殊类型: any、unknown、never、void

---
### 152. 检测CSS动画的fps
通过JavaScript和requestAnimationFrame方法实现，思路是每帧动画记录当前时间，通过时间差计算帧率。

---
### 153. 优化CSS和提高性能
1. 通过Webpack等工具合并和最小化CSS文件
2. 使用Sass或less这些预处理器编写高效的css代码
3. 减少复杂选择器的使用，优先选择类选择器
4. 避免冗余样式
5. 合理使用雪碧图
6. 尽量使用transform和opacity，避免复杂动画
7. CSS放在head标签内
8. 关键的样式使用内联CSS减少渲染时间
---
### 154. CSS Sprites
雪碧图，是网页性能优化技术，将多个小图标合并到一张大图中，通过CSS来控制显示具体的图标，有效减少HTTP请求次数，提高网页加载速度

---
### 155. 为什么用translate改变位置，而不是定位
translate是通过CSS transforms实现的，它操作的是元素的渲染层，而不是布局层，不会触发重排而重新计算布局；并且还会借助GPU加速。提升渲染性能

---
### 156. 使用`@link`和`@import`引用CSS的区别
1. `<link>`用于HTML文档中引用CSS，该方式加载速度更快，兼容性更好，可以通过JavaScript操作
2. `@import`可以在CSS文件中引用其他CSS文件，但由于加载速度慢，不建议在追求高性能应用中使用
---
### 157. CSS中display属性的值及其作用
none
block
inline
inline-block
flex: 弹性容器，子元素使用弹性布局
grid: 网格容器，子元素使用网格布局
table: 元素显示位块级表格容器

---
### 158. CSS中的属性继承
影响页面结构的属性不可以被继承: `background、display、height、float`
不影响页面结构的属性可以被继承: `color、font-**、text-**、line-height`

---
### 159. CSS优先级
1. `!important`优先级最高
2. 内联样式: 1000分
3. id选择器: 100分
4. 类选择器、属性选择器、伪类选择器都是10
5. 标签选择器、伪元素选择器是1
6. 继承的属性、子选择器、兄弟选择器后代选择器都是0
当选择器值相同时，后面的样式优先级高

---
### 160. CSS选择器
1. 基础选择器: 类型选择器、类选择器、ID选择器、通配符选择器
2. 层次选择器: 后代选择器、子选择器、相邻兄弟选择器、通用兄弟选择器
3. 属性选择器: `[attr=value]`
4. 伪类选择器: `:hover`、`:nth-child()`
5. 伪元素选择器: `::before`、`::after`
---
### 161. Canvas和SVG区别
1. Canvas逐像素渲染，适合实时动态绘制；SVG基于矢量描述，适合简单动态绘制
2. Canvas性能高，适合频繁更新的图形和复杂动画; SVG处理复杂图形时，性能下降
3. Canvas不具备DOM交互，需要额外时间处理代码；SVG天然支持交互和事件处理
4. Canvas适合游戏开发和复杂动画；SVG适合图标标识等高分辨率图形
---
### 162. HTML中，title和h1区别
1. `<title>`用于定义浏览器工具栏和标签页上的标题；`<h1>`用于页面内部，标识主要内容
2. `<title>`页面外可见；`<h1>`页面内可见
3. `<title>`影响搜索引擎结果页中如何展示网页，`<h1>`影响引擎对页面内容理解
---
### 162. 行内元素、块级元素和空元素
1. 行内元素: 用于文本内部，不会影响文本换行，而是在内容中连续展示, 例如`<span>`、`<a>`、`<img>`等
2. 块级元素: 会在其创建后强制换行，占据父元素的完整宽度，例如`<p>`、`<div>`、`<h1>`等
3. 空元素: 没有结束标签，不包含内容，只包含属性，例如`<br>`、`<hr>`、`<input>`等
---
### 163. img标签的srcset属性
srcset属性用于为img标签提供多个图片源和分辨率描述，浏览器会根据当前设备的屏幕分辨率选择最合适的图片源加载，有利于创建响应式页面和优化图像加载性能

---
### 164. HTML5更新
1. 语义化标签
2. 表单增强
3. 本地存储、websocket通信
4. 视频音频
5. canvas画布、drag和drop拖拽、地理位置
6. 支持离线应用
---
### 165. HTML中常见的meta标签
meta: 描述网页文档的属性
常用标签:
1. charset: 字符集
2. viewport: 确保不同设备上页面正确渲染
3. description: 页面的简短描述
4. keywords: 提升SEO
5. author: 作者
6. refresh: 设置页面一定时间刷新或重定向到另一个URL
---
### 166. script标签中defer和async区别
1. defer确保脚本按照在HTML中出现的顺序执行，async是谁先下载完谁先执行
2. async适用于不依赖脚本且不被其他脚本依赖的模块
---
### 167. DOCTYPE的作用
用于在浏览器读取HTML时标注应该以什么样的文档类型解析文档
若没有该标注，则浏览器会以怪异模式渲染网页，可能会出现不可预料的错误

---
### 168. HTML语义化
根据内容的结构和含义选择合适的HTML标签，更好的表达意义和层次，提高代码可维护性，帮助开发者快速定位

---
### 169. src和href区别
1. src是指定要加载的资源路径，用于加载JavaScript脚本、图像、音频、视频、文件。阻塞加载
2. href是指定超链接的目标地址，定义文档与外部资源的关联，主要用于`<a>`、`<link>`等标签中，非阻塞加载
---
###　170. 设计模式
一套在软件工程中经过验证的，用于解决特定设计问题的解决方案模板，帮助开发者避免反复造轮子，确保设计的一致性和可维护性，提高代码可读性和可扩展性

---
### 171. 常见的设计模式及应用场景
1. 单例模式: 保证一个对象只有一个实例，全局共享，应用Spring Bean
2. 工厂模式: 初始化时提供不同的类选择同一配置对象
3. 策略模式: 相同功能可以选择多种实现方式
4. 模板模式: 骨架定义好实现逻辑，具体通过子类实现
---
### 172. 模板方法模式
父类定义好算法骨架，具体实现步骤在子类
应用场景:
数据处理流程
Web请求处理

---
### 173. 策略模式
定义一系列算法类并封装起来，使得它们可以相互转化，让算法独立于它们的客户端调用
应用场景:
算法封装、避免条件语句、与上下文独立

---
### 174. 代理模式
不改变原始对象的情况下，通过引入一个代理对象控制原始对象的访问
应用于访问控制、性能优化、远程访问、日志记录

---
### 175. 原型模式
通过复制现有实例来创建新对象，避免复杂创建过程
应用于:
1. 文档编辑器中模板文档的创建
2. 游戏开发中怪物或物品的批量生成

---
### 176. 工厂模式工作原理
利用一个工厂作为入口，将多个对象创建和使用分离，根据传入的参数来创建并返回不同类型的对象实例

---
### 177. Cookie、Session、Token区别
1. Cookie用于跟踪和保存用户的状态信息，存储在浏览器端
2. Session用于跟踪用户在服务器上的状态信息，存储在服务器端
3. Token是一串用于验证用户身份或授权信息的加密字符串，存储在客户端，后续访问服务端要带上Token

---
### 178.OSI七层模型
1. 应用层: 用户交互界面
2. 表示层: 数据格式转换、加密、解密
3. 会话层: 建立、管理、中止会话
4. 传输层: 可靠传输、流量控制、错误检测
5. 网络层: 路径选择和逻辑地址管理
6. 数据链路层: 物理地址寻址，错误检测
7. 物理层: 比特流传输，物理连接
---
### 179. TCP/IP四层模型
1. 网络接口层负责在计算机和网络硬件间传输数据
2. 网络层通过IP协议提供数据包的路由
3. 传输层负责在两个逐级间提供端到端的通信服务
4. 应用层通过各种协议提供网络应用的功能
---
### 180. TCP滑动窗口作用
实现流量控制，协调发送方和接收方的数据传输速率，确保发送方的数据量不会超过接收方的接收能力

---
### 181. TCP超时重传机制
TCP是一种可靠连接，数据传输过程中，可能会因为网络阻塞等问题导致数据包丢失或延迟到达，若指定时间内没有收到对方应答的响应报文，则会触发超时重传机制，确保数据可靠到达

---
### 182. TCP回收的TIME_WAIT状态
1. 确保最后的ACK被成功接收，
2. 防止旧的重复分段干扰新连接

---
### 183. 四次挥手
1. 第一次: 客户端主动关闭连接，发送FIN包，进入FIN_WAIT_1状态；服务端接收到FIN后不再接收数据
2. 第二次: 服务端发送ACK包，确认收到FIN。服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态
3. 第三次: 服务器完成数据传输后，发送FIN包，进入LAST_ACK状态，客户端收到FIN后，准备关闭
4. 第四次: 客户端发送最后一个ACK包，进入TIME_WAIT状态，等待可能迟到的FIN。服务器收到ACK后，关闭连接，进入CLOSE状态。客户端在TIME_WAIT计时结束后，关闭连接
   
---
### 184. 三次握手
1. 第一次: 客户端发送一个SYN消息给服务器
2. 第二次: 服务器收到后回复一个SYN-ACK消息
3. 第三次，客户端再发送一个ACK确认收到SYN-ACK消息

---
### 185. 粘包和拆包
1. 粘包是TCP传输中，发送方的多个数据包在接收方被合并成一个包接收，接收方无法区分消息边界
   拆包是发送方的数据包在接收方被分成了多个包接收，接收方无法一次性接收到完整数据
2. 粘包是由于TCP是面向字节流协议，不关心数据边界，数据在发送方被一次性发送，接收方读取时就可能将多个消息拼在一起
   拆包可能是由于网络传输中的MTU限制或缓冲区大小限制，一个大包被分成了小包
3. 解决方法:
   使用定长消息: 接收方可根据设定好的固定消息长度，来接收消息
   添加消息分隔符: 每个消息之间添加特定分隔符，接收方根据分隔符区分消息
   添加消息头: 在消息头部指示消息长度，接收方根据长度读取相应长度消息
---
### 186. TCP和UDP
TCP提供了可靠、面向连接的传输，适用于需要数据完整性和顺序的场景
UDP提供了不可靠、轻量、面向报文的传输，适用于实时性要求高的场景

---
### 187. TCP解决的问题
1. TCP确保数据在传输过程中不丢失、不重复、按顺序到达。提供可靠性传输
2. TCP通过滑动窗口机制防止接收方因处理数据能力有限而被数据淹没
3. TCP通过拥塞避免算法防止网络过载，确保资源的稳定
4. TCP通过三次握手，四次挥手的机制确保通信的可靠性

---
### 188. HTTP和HTTPS
1. http以明文传输，容易被窃听篡改；https通过SSL/TLS对数据进行加密传输，确保机密性
2. http默认端口80；https默认端口443
3. http无加密过程，连接速度快；https需要加密过程，速度稍慢
4. 搜索引擎一般会降低未加密站点(http)的排名，https优先度高
---
### 189. Http1.0、Http1.1、HTTP2.0和3.0的区别
- HTTP1.0
  增加了HEAD、POST请求
  增加了状态响应码
  增加了头部
  在请求加入了HTTP版本
  引入了content-type，支持传不同数据
- HTTP1.1
  引入keepalive，允许持久连接
  支持pipeline，无需等待前面请求响应即可直接发请求
  加入Host头指定服务器域名
- HTTP2.0
  二进制协议，将数据分割为消息和帧，用二进制编码
  多路复用，请求共用一个连接
  使用HPACK算法对头部数据压缩，减少请求数据大小
  允许服务端推送资源给客户端
- HTTP3.0
  基于UDP，使用QUIC保证多路复用和可靠性
  解决TCP队头堵塞问题
  使用TLS1.3加密，安全性高，强制加密
  QUIC协议集合建立连接和加密握手，不再需要TCP的三次握手和TSL握手

---
### 189. TCP连接
TCP连接是一种网络协议, 提供了一种面向连接、可靠、基于字节流的通信服务

---
### 190. Nodejs的事件循环机制
事件循环允许nodejs可以在单个线程中处理高并发请求，提高了程序的性能和相应能力
流程:
1. nodejs启动脚本后会初始化事件循环
2. 执行输入的脚本，注册各种事件
3. 事件循环开始，进入不同阶段。每个阶段处理特定类型事件
4. 当事件队列的事件处理完毕，事件循环会检查是否有待处理的事件或回调，若有，则继续运行处理时间；没有则退出程序。
---
### 191. 解释一下路由守卫的概念和用法，并介绍它在项目中的使用场景
路由守卫让我们在路由导航过程中进行拦截和处理，三种类型:
1. 全局守卫
   router.beforeEach: 在路由跳转前触发
   router.beforeResolve: 在导航被确认时触发
   router.afterEach: 导航完成后触发
2. 路由独享守卫
   beforeEnter: 直接在路由配置上定义，进入路由时触发
3. 组件内守卫
   beforeRouterEnter: 在渲染对应路由被验证前调用
   beforeRouterUpdate: 在当前路由改变，但组件被复用时调用
   beforeRouterLeave: 在导航离开组件的对应路由时调用
