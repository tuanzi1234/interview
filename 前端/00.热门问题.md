### 一、如何在Node.js中进行高效的日志处理
- 异步日志记录: 使用异步方式记录日志，避免阻塞线程
- 日志级别控制: 只记录重要的日志, 例如错误日志
- 日志轮转: 限制日志文件大小
- 批量日志写入: 批量写入日志，将日志积累到一定程度再写入磁盘
- 日志缓冲机制: 将日志先写入内存缓冲区，定时或达到一定大小时再写入磁盘
---
### 二、Node.js的事件循环
事件循环是一个永远运行的循环，使得Node.js能非阻塞地执行I/O操作，即使在执行其他操作时也能处理新请求
事件循环分为几个阶段:
- Timer(定时器阶段): 主要处理setTimeout()和setInterval()的回调函数
- I/O Callbacks(I/O 回调阶段): 主要处理大部分的回调
- Idle, prepare(空闲、准备阶段): 内部使用阶段，不对用户公开
- Poll(轮询阶段): 查看是否有新的I/O事件，如果有则处理，没有则休眠等待任务
- Check(检查阶段): 专门处理setImmediate()的回调函数
- Close Callbacks(关闭回调阶段): 主要处理socket的close事件
---
### 三、Node.js回调、Promise和Async/Await区别
- 回调: 最基本的异步处理方式，将一个函数作为参数传递给另一个函数，异步操作完成后调用这个回调函数
- Promise: 封装异步操作，返回一个Promise对象，通过then()方法处理异步操作的结果
- async/await: 基于Promise的语法糖，将Promise转换为同步代码，使用起来更方便。错误处理使用try...catch
---
### 四、非阻塞I/O
- 非阻塞I/O: 在输入输出时不需要等待数据传输完毕，可以允许系统继续执行其他任务，提高系统的并发性。
---
### 五、事件发射器
- 事件发射器: 可以创建、触发和监听事件。允许我们对异步事件进行订阅并在事件发生时执行回调函数。
- 使用:
  ```javascript
  const EventEmitter = require('events'); // 1. 引入事件发射器模块
  const emitter = new EventEmitter(); // 2. 创建事件发射器实例

  // 3. 监听事件
  emitter.on('event', (data) => { // 监听事件
    console.log('Event triggered:', data);
  })
  // 4. 触发事件
  emitter.emit('event', 'Hello, World!'); // 触发事件
  ```
---
### 六、setImmediate()和setTimeout()的区别
它们都是用来调度异步任务的定时器
区别:
1. 执行时机: setImmediate()允许当前事件循环结束后立即执行回调函数，setTimeout()允许指定延迟时间后执行回调函数
2. 优先级: setImmediate()的回调函数优先级高于setTimeout()的回调函数
3. 使用场景: setImmediate()适用于需要立即执行的任务，而setTimeout()适用于需要延迟执行的任务
---
### 七、Node.js的process.nextTick()
process.nextTick()是一个用于将回调函数插入到当前执行栈底部，它优先于队列中的所有回调函数执行。

---
### 八、Node.js的require和import的区别
二者都是用于导入模块的，但是它们有区别:
1. 模块规范: require使用CommonJS规范，import使用ES6模块规范
2. 语法: require使用`const module = require('路径');`，import()使用`import 模块名 from '路径';`
3. 执行时机: require是同步加载模块并立即执行，import是异步加载模块
4. 支持范围: require在Node.js中原生支持，import需要使用Babel等编译器支持才能在node.js中使用
  ---
### 九、Node.js的process对象及其常用属性
process对象提供了有关node.js的进程信息和控制，任何地方都可直接使用
常用属性:
- process.argv: 获取命令行参数
- process.env: 获取环境变量
- process.exit(): 退出进程
- process.cwd(): 获取当前进程工作目录
- process.memoryUsage(): 获取进程内存使用情况
- process.uptime(): 获取进程运行时间
- process.nextTick(): 下一次事件循环中调用的回调函数
---
### 十、Node.js的模块加载
node.js使用CommonJS规范进行模块加载。使开发者将代码分成独立的文件和模块进行组织和复用。
加载过程包括路径解析，文件类型识别，编译和缓存等步骤

---
### 十一、Node.js解析JSON
使用JSON.parse()方法将JSON字符串解析为JavaScript对象:
```javascript
const jsonString = '{"name": "John", "age": 30}';
const jsonObject = JSON.parse(jsonString);
console.log(jsonObject.name); // John
console.log(jsonObject.age); // 30
```
---
### 十二、Node.js的Buffer对象
Buffer对象用于处理二进制数据，提供对内存缓冲区的操作能力
作用:
- 处理二进制数据: 用于读取视频、图片、文件等二进制数据
- 与流结合: 用于文件处理，网络传输
- 转换编码格式: 将不同编码格式的字符串相互转换
---
### 十三、Node.js的全局对象
全局对象是node.js中内置的、可以直接访问的、无需导入的JavaScript对象。
- global: 全局命名空间对象，类似于window对象
- process: 进程对象，用于获取进程信息、控制进程等
- __dirname和__filename: 当前文件所在目录的绝对路径和当前文件绝对路径
- console: 控制台对象，用于打印日志、错误信息等
- module和exports: 模块对象，用于导出模块内容、导入模块内容
- 定时器函数: setTimeout()、setInterval()、clearTimeout()、clearInterval()
- Buffer: 用于处理二进制数据
---
### 十四、package.json文件
package.json文件是node.js项目配置文件，
包含了:
- 描述项目基本信息: 名称、版本、描述等
- 依赖项: 项目依赖的模块列表
- 脚本: 项目的启动、测试、打包等脚本
- 配置项: 项目的配置项，如入口文件、仓库地址等
---
### 十五、回调函数
回调函数是一种将函数作为参数传递给另一个函数的机制，通常用于异步处理。
```javascript
const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) => { // 其中，第三个参数是回调函数
  if (err) throw err;
  console.log(data);
})
```
---
### 十六、npm
npm是node.js的包管理工具，用于安装、更新、卸载和搜索javascript包和依赖。
npm管理项目依赖:
1. 初始化项目: `npm init -y` 生成package.json文件
2. 安装依赖: `npm install 包名` 安装指定包
3. 保存依赖: `npm install 包名 --save`(默认自动保存)
4. 更新依赖: `npm update 包名`
5. 卸载依赖: `npm uninstall 包名`
---
### 十七、同步和异步
同步: 这种代码会阻塞后续代码执行，直到该代码执行完毕。
异步: 这种代码不会阻塞后续代码执行，当该代码执行完毕时，会通过回调函数、Promise、async/await等机制将结果返回给调用方。

---

### 十八、nodejs中创建服务器
1. 引入http模块: `const http = require('http');`
2. 创建服务器: 
   ```javascript
   const server = http.createServer((req, res) => {
     res.statusCode = 200; // 设置响应状态码
     res.setHeader('Content-Type', 'text/plain'); // 设置响应头
     res.end('Hello World\n'); // 发送响应数据
   });
   ```
3. 监听端口: 
    ```javascript
    const port = 3000;
    server.listen(port, () => {
      // 启动成功
    })
    ```
---
### 十九、登录鉴权及其优缺点
1. Session-Cookie: 用户登录后，创建一个会话(Session)并将其id存入cookie中。后续请求中，客户端携带cookie维持会话状态。
   优点: 状态管理清晰，适用于服务端渲染的web应用
   缺点: 会话信息存储在服务端，不适合分布式应用，加重服务器负担
2. Token认证(JWT): 利用JSON Web Token(JWT)加密的令牌标识用户的身份，登录成功后，服务器生成的token返回客户端，后续携带该token进行身份验证。
   优点: 减少服务器状态存储，适用于分布式应用和前后端分离应用
   缺点: Token过期失效控制较难，增加令牌保护复杂性
3. OAuth2.0: 允许用户不暴露用户名密码的情况下，使用第三方访问其受保护的资源(支付宝、微信等)，第三方账号会随着用户登录将授权信息传递到服务器完成鉴权
   优点: 避免了账户管理，方便用户
   缺点: 需要第三方授权，适用性窄
---
### 二十、页面请求接口大规模并发解决方案
1. 前端并发控制:
   请求合并: 将同类型的请求合并成一个请求
   请求队列: 实现请求排队机制，控制请求数量
   防抖节流: 对频繁触发的请求进行控制
2. 数据缓存:
   前端缓存: 利用浏览器缓存数据
   接口缓存: 合理设置Http缓存头，利用CDN缓存
3. 后端并发控制:
   数据库优化: 适当添加索引，优化查询语句
   服务端优化: 使用Redis等中间件





