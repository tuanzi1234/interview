### 1. 如何在Node.js中进行高效的日志处理
- 异步日志记录: 使用异步方式记录日志，避免阻塞线程
- 日志级别控制: 只记录重要的日志, 例如错误日志
- 日志轮转: 限制日志文件大小
- 批量日志写入: 批量写入日志，将日志积累到一定程度再写入磁盘
- 日志缓冲机制: 将日志先写入内存缓冲区，定时或达到一定大小时再写入磁盘
---
### 2. Node.js的事件循环
事件循环是一个永远运行的循环，使得Node.js能非阻塞地执行I/O操作，即使在执行其他操作时也能处理新请求
事件循环分为几个阶段:
- Timer(定时器阶段): 主要处理setTimeout()和setInterval()的回调函数
- I/O Callbacks(I/O 回调阶段): 主要处理大部分的回调
- Idle, prepare(空闲、准备阶段): 内部使用阶段，不对用户公开
- Poll(轮询阶段): 查看是否有新的I/O事件，如果有则处理，没有则休眠等待任务
- Check(检查阶段): 专门处理setImmediate()的回调函数
- Close Callbacks(关闭回调阶段): 主要处理socket的close事件
---
### 3. Node.js回调、Promise和Async/Await区别
- 回调: 最基本的异步处理方式，将一个函数作为参数传递给另一个函数，异步操作完成后调用这个回调函数
- Promise: 封装异步操作，返回一个Promise对象，通过then()方法处理异步操作的结果
- async/await: 基于Promise的语法糖，将Promise转换为同步代码，使用起来更方便。错误处理使用try...catch
---
### 4. 非阻塞I/O
- 非阻塞I/O: 在输入输出时不需要等待数据传输完毕，可以允许系统继续执行其他任务，提高系统的并发性。
---
### 5. 事件发射器
- 事件发射器: 可以创建、触发和监听事件。允许我们对异步事件进行订阅并在事件发生时执行回调函数。
- 使用:
  ```javascript
  const EventEmitter = require('events'); // 1. 引入事件发射器模块
  const emitter = new EventEmitter(); // 2. 创建事件发射器实例

  // 3. 监听事件
  emitter.on('event', (data) => { // 监听事件
    console.log('Event triggered:', data);
  })
  // 4. 触发事件
  emitter.emit('event', 'Hello, World!'); // 触发事件
  ```
---
### 6. setImmediate()和setTimeout()的区别
它们都是用来调度异步任务的定时器
区别:
1. 执行时机: setImmediate()允许当前事件循环结束后立即执行回调函数，setTimeout()允许指定延迟时间后执行回调函数
2. 优先级: setImmediate()的回调函数优先级高于setTimeout()的回调函数
3. 使用场景: setImmediate()适用于需要立即执行的任务，而setTimeout()适用于需要延迟执行的任务
---
### 7. Node.js的process.nextTick()
process.nextTick()是一个用于将回调函数插入到当前执行栈底部，它优先于队列中的所有回调函数执行。

---
### 8. Node.js的require和import的区别
二者都是用于导入模块的，但是它们有区别:
1. 模块规范: require使用CommonJS规范，import使用ES6模块规范
2. 语法: require使用`const module = require('路径');`，import()使用`import 模块名 from '路径';`
3. 执行时机: require是同步加载模块并立即执行，import是异步加载模块
4. 支持范围: require在Node.js中原生支持，import需要使用Babel等编译器支持才能在node.js中使用
  ---
### 9. Node.js的process对象及其常用属性
process对象提供了有关node.js的进程信息和控制，任何地方都可直接使用
常用属性:
- process.argv: 获取命令行参数
- process.env: 获取环境变量
- process.exit(): 退出进程
- process.cwd(): 获取当前进程工作目录
- process.memoryUsage(): 获取进程内存使用情况
- process.uptime(): 获取进程运行时间
- process.nextTick(): 下一次事件循环中调用的回调函数
---
### 10. Node.js的模块加载
node.js使用CommonJS规范进行模块加载。使开发者将代码分成独立的文件和模块进行组织和复用。
加载过程包括路径解析，文件类型识别，编译和缓存等步骤

---
### 11. Node.js解析JSON
使用JSON.parse()方法将JSON字符串解析为JavaScript对象:
```javascript
const jsonString = '{"name": "John", "age": 30}';
const jsonObject = JSON.parse(jsonString);
console.log(jsonObject.name); // John
console.log(jsonObject.age); // 30
```
---
### 12. Node.js的Buffer对象
Buffer对象用于处理二进制数据，提供对内存缓冲区的操作能力
作用:
- 处理二进制数据: 用于读取视频、图片、文件等二进制数据
- 与流结合: 用于文件处理，网络传输
- 转换编码格式: 将不同编码格式的字符串相互转换
---
### 13. Node.js的全局对象
全局对象是node.js中内置的、可以直接访问的、无需导入的JavaScript对象。
- global: 全局命名空间对象，类似于window对象
- process: 进程对象，用于获取进程信息、控制进程等
- __dirname和__filename: 当前文件所在目录的绝对路径和当前文件绝对路径
- console: 控制台对象，用于打印日志、错误信息等
- module和exports: 模块对象，用于导出模块内容、导入模块内容
- 定时器函数: setTimeout()、setInterval()、clearTimeout()、clearInterval()
- Buffer: 用于处理二进制数据
---
### 14. package.json文件
package.json文件是node.js项目配置文件，
包含了:
- 描述项目基本信息: 名称、版本、描述等
- 依赖项: 项目依赖的模块列表
- 脚本: 项目的启动、测试、打包等脚本
- 配置项: 项目的配置项，如入口文件、仓库地址等
---
### 15. 回调函数
回调函数是一种将函数作为参数传递给另一个函数的机制，通常用于异步处理。
```javascript
const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) => { // 其中，第三个参数是回调函数
  if (err) throw err;
  console.log(data);
})
```
---
### 16. npm
npm是node.js的包管理工具，用于安装、更新、卸载和搜索javascript包和依赖。
npm管理项目依赖:
1. 初始化项目: `npm init -y` 生成package.json文件
2. 安装依赖: `npm install 包名` 安装指定包
3. 保存依赖: `npm install 包名 --save`(默认自动保存)
4. 更新依赖: `npm update 包名`
5. 卸载依赖: `npm uninstall 包名`
---
### 17. 同步和异步
同步: 这种代码会阻塞后续代码执行，直到该代码执行完毕。
异步: 这种代码不会阻塞后续代码执行，当该代码执行完毕时，会通过回调函数、Promise、async/await等机制将结果返回给调用方。

---

### 18. nodejs中创建服务器
1. 引入http模块: `const http = require('http');`
2. 创建服务器: 
   ```javascript
   const server = http.createServer((req, res) => {
     res.statusCode = 200; // 设置响应状态码
     res.setHeader('Content-Type', 'text/plain'); // 设置响应头
     res.end('Hello World\n'); // 发送响应数据
   });
   ```
3. 监听端口: 
    ```javascript
    const port = 3000;
    server.listen(port, () => {
      // 启动成功
    })
    ```
---
### 19. 登录鉴权及其优缺点
1. Session-Cookie: 用户登录后，创建一个会话(Session)并将其id存入cookie中。后续请求中，客户端携带cookie维持会话状态。
   优点: 状态管理清晰，适用于服务端渲染的web应用
   缺点: 会话信息存储在服务端，不适合分布式应用，加重服务器负担
2. Token认证(JWT): 利用JSON Web Token(JWT)加密的令牌标识用户的身份，登录成功后，服务器生成的token返回客户端，后续携带该token进行身份验证。
   优点: 减少服务器状态存储，适用于分布式应用和前后端分离应用
   缺点: Token过期失效控制较难，增加令牌保护复杂性
3. OAuth2.0: 允许用户不暴露用户名密码的情况下，使用第三方访问其受保护的资源(支付宝、微信等)，第三方账号会随着用户登录将授权信息传递到服务器完成鉴权
   优点: 避免了账户管理，方便用户
   缺点: 需要第三方授权，适用性窄
---
### 20. 页面请求接口大规模并发解决方案
1. 前端并发控制:
   请求合并: 将同类型的请求合并成一个请求
   请求队列: 实现请求排队机制，控制请求数量
   防抖节流: 对频繁触发的请求进行控制
2. 数据缓存:
   前端缓存: 利用浏览器缓存数据
   接口缓存: 合理设置Http缓存头，利用CDN缓存
3. 后端并发控制:
   数据库优化: 适当添加索引，优化查询语句
   服务端优化: 使用Redis等中间件
---
### 21. Webpack性能优化
1. 代码分割: 通过动态导入，将代码分割成多个模块，按需加载
2. 资源压缩: 使用TerserWebpackPlugin对javascript代码进行压缩，并使用css-minimizer-plugin对css进行压缩。
3. 图片优化: 使用image-webpack-loader对图片进行压缩。
4. 预加载: 使用prefetch或preload对静态资源进行预加载。
5. 缓存管理: 设置合适的缓存策略，通过hash文件名管理缓存。
6. Tree Shaking: ES6模块的静态代码分析，去除未使用的代码。
---
### 22. Webpack作用
Webpack是一个前端资源打包工具，将复杂的项目模块化管理，转化成浏览器友好的代码，提高开发效率和性能
1. 模块化: 将项目拆分成多个模块，优化代码结构加载速度
2. 按需加载: 将代码拆分，实现按需加载，减少初次加载时间
3. 资源管理: 通过各种加载器和插件，处理样式、图片、字体等
4. 开发友好: 提供热更新、实施重载等功能
---
### 23. 使用Webpack和LocalStorage实现静态资源离线缓存
结合Service Worker和LocalStorage，可以实现静态资源离线缓存。
1. 配置Webpack: 添加Service Worker配置，并设置缓存策略。
2. 使用Service Worker缓存资源: Service Worker会监听用户网络请求，将资源缓存在浏览器
3. 使用LocalStorage存储资源: LocalStorage可以存储用户配置，上次访问时间等信息。
--- 
### 24. Webpack的图片处理加载器
1. file-loader: 将图片文件复制到输出目录，返回其URL。
2. url-loader: 类似于file-loader，但可以将图片转为base64编码，嵌入javascript中。
3. image-webpack-loader: 对图片进行压缩调整大小。
4. responsive-loader: 根据屏幕宽度，生成多尺寸的图片。
---
### 25. Webpack优化产出代码
1. 代码分割: 使用splitChunks插件，将代码分割成多个模块，按需加载。
2. Tree Shaking: 使用ES6模块，去除未使用的代码。
3. 压缩和混淆: 使用TerserWebpackPlugin对javascript代码进行压缩。
4. 资源优化: 使用image-webpack-loader对图片进行压缩。
5. 开启生产模式: 通过设置mode为production启动内置优化。
---
### 26. webpack-dev-server监控文件
1. 安装webpack-dev-server
2. 在webpack.config.js中添加devServer选项
3. 在package.json的scripts中添加启动命令
---
### 27. 前端开发优化网络请求
1. 减少http请求
2. 使用缓存
3. 采用懒加载
4. 采用内容分发网络(CDN)
5. 压缩优化资源
6. 使用预加载和预取
--- 
### 28. Webpack解决跨域问题
1. 安装Webpack和WebpackDevServer
2. 在webpack.config.js中添加devServer选项，设置代理
3. 在命令行中使用`npx webpack serve`启动服务后，通过代理路径访问API
---
### 29. Webpack处理内联css
安装style-loader和css-loader配合实现，前者将CSS内联到JavaScript文件中，
后者负责解析`@import`和`url()`等语句。

---
### 30. Webpack和rollup、parcel构建工具区别
1. webpack: 兼容性好，可处理各种文件类型; 高度自定义和灵活性，根据项目需求配置各种功能; 缺点是配置很复杂，构建速度慢
2. Rollup: 适合构建JS库，对模块化的支持很好能生成轻量化代码。缺点是不适合大型页面应用
3. Parcel: 适合小项目，构建速度快，支持多种文件类型，缺点是功能简单，缺乏高级优化控制
---    
### 31. Live-Reload自动刷新和HMR热模块替换区别
二者均是自动化工具，区别:
1. live-reload: 当文件发生变化时，它会自动刷新整个页面
2. HMR: 它只会替换更新的模块，而不需要重新加载整个页面
---
### 32. 前端使用Webpack进行高效优化
1. 入口分包: 合理配置多个入口文件，为不同页面生成不同文件
2. 公共代码提取: 将公共代码提取到一个单独的包中，减少重复
3. 懒加载: 通过动态导入实现懒加载，只在需要时加载模块
4. 异步模块提取: 将异步加载的模块和同步模块区分开，异步模块单独打包
---
### 33. Webpack实现条件组件按需打包
1. 动态导入
   使用`import()`语法，在需要时动态加载模块。
2. 代码分割
   Webpack的代码分割功能，可以将应用程序分成多个包
---
### 34. Webpack Loader
1. babel-loader: 将ES6替换为向后兼容的JavaScript代码
2. ts-loader: 将TypeScript转换为JavaScript
3. css-loader: 解析CSS的`@import`和`url()`
4. style-loader: 将CSS注入到DOM的style标签中
5. sass-loader: 将Sass和Scss编译成CSS
6. file-loader: 处理文件，返回文件URL
7. url-loader: 类似于file-loader，但当文件小于设定的字节限制时，返回base64编码的Data Url
---
### 35. Webpack插件底层实现原理
1. Tapable库: Webpack使用Tapable库来管理和调度各个钩子函数，这些钩子允许在构建过程的特定时机插入逻辑
2. 插件机制: 插件通过apply方法访问Webpack生命周期钩子，并在适当位置注入自定义逻辑
---
### 36. 前端项目的缓存配置策略
1. 强缓存
2. 协商缓存
3. 按需缓存
4. 预加载
---
### 37. 优化Webpack打包后的文件体积
1. 代码拆分: 将大的源文件拆分成更小的文件按
2. 使用Tree Shaking: 剔除未被使用的JavaScript代码
3. 启用压缩: 使用压缩插件对JavaScript代码和静态资源进行压缩
4. 合理设置第三方库的按需引入
5. 移除无用插件和polyfills
---
### 38. 常用前端性能分析工具
1. Chrome DevTools
2. Lighthouse
3. WebPageTest
4. GTmetrix
5. PageSpeed Insights
6. New Relic
---
### 39. 网站优化关键
1. 减少http请求: 合并CSS和JavaScript文件
2. 使用内容芬达网络(CDN): 静态资源托管在CDN上
3. 优化图像: 压缩图像或使用WebP格式
4. 启用浏览器缓存
5. 代码压缩和混淆
6. 异步加载资源
7. 减少重绘和重排
8. 使用http/2
---
### 40. 前端项目中配置HTTP缓存机制
1. 使用浏览器缓存控制Http头部字段:
   - Cache-Control
   - ETag
   - Last-Modified
2. 服务器端配置缓存策略，如Nginx或Apache
   合理划分缓存策略
   配置不同资源类型的缓存时间
---
### 41. 优化Webpack打包速度
1. 合理利用缓存
2. 分割代码
3. 多进程并行压缩
4. 减少解析范围
5. 使用更快的编译器
---
### 42. Webpack处理node_modules的依赖
1. 通过enhanced-resolve解析模块路径
2. 根据package.json中的配置字段确定模块入口文件
3. 使用配置的loader处理模块内容，转化为webpack理解的JavaScript代码
---
### 43. CoreWebVitals
Core Web Vitals是谷歌提出的核心网页指标，用于衡量网站的用户体验
1. LCP: 最大内容渲染时间, 衡量加载性能, 小于2.5秒
2. INP: 交互后下一帧的绘制时间, 衡量互动性, 200ms内
3. CLS: 累计布局偏移, 衡量视觉稳定, 0.1s内
---
### 44. Webpack的bundle、chunk、module
1. module(模块): 项目中被引入的文件对于webpack都是模块
2. chunk(代码块): webpack打包过程中，一组module的集合
3. bundle(打包结果): 最终输出的一个或多个打包结果
---
### 45. 同一页面3个组件请求同一个API并发发送3次请求优化
1. 利用全局状态管理工具来管理和共享数据
2. 在父组件中请求数据，通过props传递给子组件
3. 使用请求缓存机制，将API的请求结果缓存起来
--- 
### 46. 前端项目中，如何优化首屏渲染
1. 加载优化
   - 路由懒加载
   - 资源预加载
   - 合理使用服务端渲染
2. 资源优化
   - 代码分割
   - 静态资源压缩
   - 图片优化
3. 缓存优化
   - 浏览器缓存
   - 本地缓存
4. 代码优化
   - 避免重复渲染
   - 减少主线程阻塞

---
### 47. 用户输入网址到网页显示过程
1. 浏览器解析url
2. 请求dns服务器获取ip地址
3. 建立tcp连接
4. https握手
5. 发送http请求，先封装成tcp段，再封装成ip数据包，最后在链路层封装成帧，由物理层发出
6. 服务器处理请求，返回对应数据
7. 浏览器接收到响应，渲染页面，执行js
8. 显示页面
---
### 48. 处理前端一次性返回超大属性结构数据
1. 懒加载, 点击到子节点再去渲染相应的组件
2. 虚拟滚动树形结构, 只渲染可见区域的节点
3. 缓存机制, 利用浏览器缓存已经加载的数据
4. 分页, 对于同级大量节点采用分页展示
---
### 49. 渲染10万条数据且不卡顿的解决方案
1. 虚拟滚动，只渲染可见区域的数据
2. 分页渲染，将数据分批次渲染

---

### 50. 浏览器执行100w个任务不卡顿
任务分批次处理，避免主线程阻塞
1. requestAnimationFrame: 每一帧处理一部分任务
2. setTimeout/setInterval: 通过定时器分批处理任务
3. MessageChannel: 利用微任务队列，分批次调度任务
4. requestIdleCallback: 浏览器空闲时执行任务
---
### 51. 扫码登录
1. 获取二维码
   网页端向后端请求生成唯一标识(uuid), 转换成二维码
2. 轮询二维码状态
   定时向后端轮询，查看uuid对应的扫码状态
3. 手机端扫码与授权
   微信扫一扫扫描二维码，识别uuid和回调，授权同意后，微信会回调，携带临时code
4. 后端处理授权
   后端收到回调后，用code换取access_token和openid, 与uuid绑定，写入缓存
5. 登录成功
   前端轮询发现uuid被授权，获取登录信息，跳转页面
---
### 52. 设计能够统计前端页面请求耗时的工具
核心思路是拦截和记录每一次网络请求发起和结束的时间，计算耗时
1. 全局重写XMLHttpRequest和fetch方法，再请求发起和响应时间记录时间点，计算耗时
2. 通过`performance.getEntriesByType("resource")`方法获取所有请求详细耗时
---
### 53. 设计和优化秒杀系统前端
1. 界面设计
   界面简洁明了，用户能快速理解相关功能及物品信息
2. 性能优化
   使用懒加载、CDN加速资源加载等方式优化页面性能
3. 防止刷量和攻击
   利用验证码等功能防止机器人刷量
   使用WebSocket实时获取服务器数据，避免频繁刷新页面
4. 用户体验
   秒杀时提供即时反馈，成功或失败后，提供明确的信息
---
### 54. 在无限滚动加载内容时回收上面的内容
核心思路是，指渲染可视区域附近的内容，超出可视区域的内容就从DOM中移除替换为占位元素，用户滚动时动态加载和卸载内容。
利用VirtualList组件可以做到只渲染当前可见内容和一定缓冲区的内容。

---
### 55. 前端实现断点续传，传输大文件
思路: 将大文件分割成小块，每个小块单独上传，如果网络中断，只需上传未完成的块
1. 使用File对象的slice方法，切割文件
2. 计算文件的MD5值，用于服务器校验和断点续传
3. 每个分片通过接口单独上传
4. 记录上传进度，确保断网后可恢复上传
5. 分片上传完成后，通知服务端合并文件
---
### 56. 前端基于WebSocket实现实时聊天
1. WebSocket实现实时通信
   通过WebSocket可以和后端服务器保持长连接，实时收发消息
2. 多用户在线聊天流程
   - 用户登录后，前端建立WebSocket连接，并将用户消息发送给服务器
   - 服务器维护在线用户的连接消息
   - 服务器将用户发送的消息广播给目标用户或群组
   - 前端监听WebSocket消息，收到消息后更新聊天窗口
3. 消息通知
   通过浏览器的Notification API实现消息通知
---
### 57. 解决前端SPA应用首屏加载慢
原因在于需要加载大量js和css资源
解决方案:
1. 路由使用动态导入实现懒加载
2. 异步非关键的js
3. 静态资源部署到CDN
### 58. 设计前端日志埋点SDK
日志埋点SDK可以帮助开发者手机用户在应用中的行为数据，性能指标和异常信息
架构组成:
1. 采集层: 负责收集各类数据
2. 处理层: 对数据进行过滤
3. 传输层: 将数据发送到服务器
4. 缓存层: 在网络不可用时临时存储数据
5. 配置层: 控制SDK行为和采样率等等
---
### 59. 禁止调试前端代码
1. 通过不断触发debugger语句阻止正常调试
2. 检测浏览器窗口的大小，打开开发者工具会改变窗口大小，超过阈值执行防御措施
3. 监测代码执行前后时间差来判断是否处于调试状态
4. 禁止常用的打开开发者工具的快捷键
5. 使用第三方库disable-devtool等
---
### 60. 单点登录及其原理
单点登录是一种用户登录方式，用户只需要登录一次，就能访问多个相关但独立的系统。
实现方式:
1. 共享Cookie, 子系统使用相同父域名，将信息存储在父域名cookie中
2. 跨域SSO-CAS模式。中央认证服务器实现跨域单点登录
3. 基于JWT的SSO，使用JSON Web Token在多个系统间传递用户信息
---
### 61. 前端页面白屏原因
1. 资源加载失败，检查浏览器开发者工具是否有异常状态码
2. Javascript异常，检查控制台是否有报错信息
3. 路由配置异常，检查路由配置文件
4. 首屏渲染问题，如果接口响应慢会使页面长时间空白
5. 服务器渲染异常，检查服务器日志
6. 样式问题，可能设置了display:none等样式导致页面空白
7. 浏览器兼容问题，可尝试切换不同浏览器
---
### 62. 当前端静态资源加载失败时，降级处理
1. 图片加载失败时，监听图片的onerror事件，将图片替换为默认图片
2. JS/CSS加载失败时，监听onerror事件，提示用户刷新
3. 配置多个CDN源地址，主源失败时负责兜底
4. 关键JS加载失败时，可以展示简化页面，确保基础信息可见
5. 通过window.onerror监听全局错误，并记录日志
--- 
### 63. 给网页添加水印，防止水印被擦除
1. 原生HTML/CSS:
   在页面上层插入div，设置pointer-events: none; 内容为水印文字 使用position: fixed; 覆盖页面
2. Canvas:
   用canvas绘制水印，将其设置为body或某个容器的背景图片，用repeat平铺。
3. 防止页面擦除
   - 监听DOM变化，用MutationObserver监控，若水印被修改，则重新添加
   - 多层水印，增加移除难度
   - 禁止pointer-events
   - 混淆class/id, 让其随机生成，防止通过选择器删除
   - 部分敏感场景可让后端生成
---
### 64. 实现主题切换
1. 在CSS中定义一套基础变量
2. 在需要切换的地方都用上该变量
3. 通过JS修改根节点的data-theme属性
4. 用localStorage保存当前主题，下次打开时读取
---
### 65. 实现页面截图
1. 使用html2canvas或DOM-to-Image，它通过遍历页面元素并在Canvas上绘制元素来生成图片
2. 简单场景可以直接使用Canvas API
---
### 66. 实现PC段访问Web应用，移动端展示H5应用
1. 通过JavaScript通过User-Agent判断访问环境
2. 通过CSS媒体查询实现响应式布局，根据屏幕宽度切换样式
3. 服务端渲染，根据请求头来判断设备类型，返回对应HTML
4. 单页应用中，可以使用前端路由高内聚设备类型渲染不同组件
---
### 67. 前端处理超过JS的Number最大值的数字
1. 只做数据展示时，直接转成字符串
2. 需要运算时，使用BigInt，或者使用第三方库big.js等
3. 和后端约定，由后端处理大数，前端仅作展示
---
### 68. 调试和解决跨浏览器兼容问题
通常是由css和js导致的
解决方案:
1. 使用can i use 检查某特性在浏览器的兼容性情况
2. 先为现代浏览器设计完整功能，在为旧浏览器设计替代方案
---
### 69. 利用节流或防抖优化频发触发请求的搜索输入框
对于搜索框，一般会使用防抖来优化。
核心思想是，等待用户停止输入一段时间后，再发起请求，避免中间状态的无效请求。
每次用户输入都会重置延迟，直到在指定时间(通常是500ms)没有新输入时，才会执行搜索请求。
节流是指限制函数在一定时间内只执行一次，适用于滚动加载或实时预览等场景

---
### 70. 网页中有大量图片时的优化加载
1. 实现图片懒加载，当图片进入视口时才加载
2. 使用WebP或AVIF格式的图片, 它们提供更好的压缩率
3. 使用`srcset`属性根据屏幕大小提供不同尺寸的图片
4. 压缩图片，减少图片大小
5. 将图片放在CDN上，利用分布式服务器加速图片加载
---
### 71. 定位前端页面发生错误的元素
1. 使用浏览器的调试工具查看报错
2. 使用try...catch语句来捕获错误
3. 在关键位置使用console.log()来记录错误信息
---
### 72. 实现第一次访问页面不触发请求，后续进入页面自动触发请求
思路: 使用sessionStorage或localStorage来记录访问状态，区分"首次加载"和"后续进入"
进入页面时，检查本地存储中是否有访问标记，没有则不发请求并设置标记
后续进入页面检查到标记存在，则发起请求

---
### 73. 对每个JavaScript函数的执行进行拦截
1. 使用高阶函数将原函数包裹一层，在执行前后插入拦截逻辑，适用于数量有限，可控场景
2. 使用Proxy可以拦截对象上的方法调用，包括函数本身。适合批量拦截
---
### 74. 判断一个点是否在Canvas的图形内
1. 使用isPointInPath(x, y)判断点(x, y)是否在Canvas的图形内部
2. 使用isPointInStroke(x, y)判断点(x, y)是否在Canvas的图形的描边区域
---
### 75. 防止用户反复提交表单
1. 当用户点击一次提交后，立刻禁用提交按钮，防止用户重复提交表单
2. 在提交时，设置一个标志，提交完成或失败后再重置
3. 提交时添加防抖操作，防止短时间内多次触发提交
4. 每次提交表单时，携带token，由后端来校验token是否用过
---
### 76. 实现国际化，根据用户设置自动切换语言
1. 选择国际化框架：vue-i18n
2. 安装必要依赖
3. 创建翻译文件
4. 设置i18next，包括默认语言、语言检测、资源加载
5. 创建切换语言组件
--- 
### 77. 实现实时自动补全搜索框
1. 监听输入框input时间，设置防抖避免频繁请求
2. 根据用户输入异步获取匹配数据
3. 动态创建和更新候选列表，支持键盘导航
4. 实现上下箭头确认和回车确认
---
### 78. Vue性能优化方案
1. 利用代码分割按需加载组件和模块
2. 利用keep-active将不需要频繁更新的组件缓存起来，避免重复渲染
3. 减少watch和computed计算的次数，减少不必要的依赖触发
4. 避免深层次的数据观察，尽量避免使用watch的keep选项
5. 使用虚拟滚动技术减少大数据量场景下的DOM渲染数量
6. 减少不必要的全局事件监听，避免频繁触发事件
---
### 79. Vuex的state/getter/mutation/action/module作用
1. state: 存储全局共享的状态
2. Getter: 类似于计算属性，用于计算并返回基于state的衍生状态
3. Mutation: 更改state的方法，是同步的
4. Action: 类似于Mutation，但用于处理异步操作
5. Module: 为了方便管理，可以把store分成多个module
---
### 80. 开发一个任务列表应用，设计思路
1. 功能设计
   - 任务增删改查
   - 任务状态管理
   - 任务分类
   - 数据持久化
2. 组件设计
   - TaskApp 根组件
   - TaskForm 任务输入列表
   - TaskList 任务列表容器
   - TaskItem 单个任务项
   - TaskFilter 任务筛选
3. 状态管理
   简单应用，可以使用props和emit进行管理
   复杂应用可以使用VueX和Pinia进行集中管理
4. 实现步骤
   - 创建项目
   - 实现基本功能
   - 实现数据持久化
   - 添加样式和交互效果
---
### 81. v-if和v-for优先级，二者同时出现的性能优化
Vue2中，v-for优先级高于v-if; Vue3中，v-if优先级高于v-for。
可以将v-if放在v-for外面，减少不必要的循环或者判断

---
### 82. 在Vue开发过程中需要同时与多人联调接口的情况
1. 建立统一的接口管理与配置
2. 后端接口未完成时，使用Mock数据进行前端开发
3. 利用Vue CLI的devServer或Vite的server.proxy配置解决跨域问题
4. 与后端团队共同指定接口规范
5. 针对不同的后端服务创建不同的开发分支
---
### 83. 解决Vue初始化页面闪动的问题
1. 在要隐藏的元素上添加v-cloak的指令
2. 在css中添加`[v-cloak] {display: none;}`
---
### 84. Vue3的设计目标以及优化
1. 更小的框架体积，减少应用加载时间
2. 提高渲染速度和影响性能
3. 完全使用TypeScript重写，更好地支持TypeScript
4. 引入组合式API, 比选项式API更灵活
--- 
### 85. Pinia和VueX的区别
1. Pinia的API比VueX的更加简洁
2. Vuex需要手动拆分模块合并，Pinia定义不同的store就能实现状态拆分
3. Pinia具有更好的TypeScript的支持，Vuex需要更多的手动配置
4. Pinia的插件生态赞数不如Vuex丰富
---
### 86. Vue3性能提升的方面
1. 更小的包体积
2. Vue3重写了虚拟DOM实现，引入了编译时优化
3. 优化了组件初始化过程，避免了不必要的选项合并
4. 从Object.defineProperty切换到Proxy，式响应式系统更高效
5. Vue3支持了多根节点组件，减少了不必要的DOM节点创建
---
### 87. 优化Webpack打包Vue的速度
1. 通过代码分割、压缩等方式减少打包后文件体积
2. 合理配置loader和plugin, 减少不必要的配置项
3. 利用CDN加载第三方库
4. 利用缓存机制，减少打包重复构建时间
5. 使用多进程提高打包效率
6. 配置`TerserWebpackPlugin`增加打包的并发数
---
### 88. Vue首页白屏原因
1. 资源加载失败
2. JS执行错误
3. 路由配置问题
4. 首屏加载慢，渲染内容多
   
解决方案:
1. 使用webpack导入功能实现按需加载
2. 将Vue、Vuex等第三方库通过CDN引入
3. 添加全局错误处理
4. 将耗时操作放入nextTick
5. 使用骨架屏或预渲染
6. 添加加载指示器
---
### 89. Vuex的实现原理
1. Central Store: 所有的状态都被集中存储在全局store对象中
2. 状态集中管理: 所有状态的修改都必须通过特定的mutation函数
3. Getter: 类似于计算属性，允许从store中派生状态
4. Actions: 可以包含异步操作，通过dispatch调用mutation，改变状态
5. Modules: vuex支持将store分割成多个模块，增加可维护性
--- 
### 90. Vuex和localStorage的区别
1. Vuex是一种管理状态模式，用于Vue中组件之间的共享状态
2. localStorage是浏览器提供的本地存储机制，用于在客户端持久化数据