### 1. JVM内存溢出的情况
1. 堆内存不足
2. 栈空间耗尽
3. 元空间不足
4. 直接内存不足
5. 线程数过多
6. GC时间过长
---
### 2. JVM组成部分
1. 类加载子系统
2. 运行时数据区
3. 执行引擎
4. 本地方法接口
---
### 3. MySQL中select * form 千万级别数据的表，内存会飙升吗？
不会，MySQL执行查询语句时，不会将1000w的数据加载到内存中，而是逐次批次处理的方式控制内存使用，也就是说，MySQL是边查边发数据给客户端

---
### 4. MySQL三层B+树能存多少数据
B+ 树默认数据页大小16KB
假设每个数据记录主键和数据大小为1KB
那么每个叶子节点就能存储16条数据
假设每个指针6字节，索引键一般8字节，那么每个节点可以指向16 * 1024 / (6 + 8) = 1170个叶子节点
总共三层，因此，能够存储的数据总量为1170 * 1170 * 16，大约能存储2000w条数据

---
### 5. MySQL事务的二阶段提交
指为了确保redo log(重做日志)和binlog(二进制日志)之间的一致性使用的机制
二阶段提交的两个阶段:
1. 准备阶段: MySQL的InnoDB引擎会在事务提交写入redo log, 标记状态为prepare，此时redo log是预提交状态
2. 提交阶段: 当redo log状态为prepare后，MySQL server会会写入binlog，binlog写入成功后，MySQL会通知InnoDB，将redolog改为commit,完成提交
---
### 6. Spring的启动流程
1. 启动main方法
2. 创建SpringApplication对象，推断应用类型、设置初始化器、监听器、主应用类
3. 准备ConfigurableEnvironment，加载配置文件、环境变量、命令行参数
4. 创建应用上下文，加载配置类，注册bean，注入依赖
5. 对于Web应用，SpringBoot会自动启动Web容器，注册Servlet和Filter
6. 对应监听stated事件逻辑会被触发
7. 启动完成后，执行CommandLineRunner和ApplicationRunner
8. 触发ApplicationReadyEvent, 应用进入运行状态，处理业务请求。
---
### 7. SpringBoot实现自动配置
通过`@EnableAutoConfiguration`注解实现，这个注解包含`@Import({AutoConfigurationImportSelector.class})`，这个类会去扫描classpath下的所有META-INF/spring.factories文件，根据文件中指定的配置类加载响应的Bean

---
### 8. Java中HashMap的原理
HashMap是基于哈希表的数据结构，用于存储键值对。
核心是将键的哈希值映射到数组索引位置。
Java8以前通过数组+链表，Java8以后改成数据+链表+红黑树处理哈希冲突。
利用hashCode()f方法计算哈希值，使用`(n - 1) & hash`计算元素在数组的位置
初始容量为16，负载因子0.75，当元素超过12时就会触发扩容操作，容量 * 2重新分配元素位置

---
### 9. `Redisson`分布式锁的原理
确保多线程操作中, 只有一个线程能获得锁，避免并发操作导致的数据不一致问题
1. `redisson`使用`exist` + `hexist` + `hincrby`命令来保证只有一个线程能成功设置键，表示获得锁
   并且会通过`pexpire`命令为锁设置过期时间，防止死锁问题
2. 防止锁在持有过程中被其他线程抢占，`Redisson`有自动续期功能，持有锁的线程会定期续期，保证任务没结束锁不失效
3. 利用`hexists` + `del`确保只有持有锁的线程才能释放锁，防止误释放的情况
   Lua同时利用`publish`唤醒其他等待的进程
4. 支持重入锁，持有锁的进程可以多次获取同一把锁不阻塞。利用Redis的hash结构，key为线程id，重入则值加一，释放则值减一，0则被释放，执行del。
---
### 10. Java线程池核心线程数在运行过程中可以修改吗？
可以修改
`ThreadPoolExecutor`提供了`setCorePoolSize(int corePoolSize)`方法可以动态增加或减少核心线程数。
corePoolSize表示线程池中的核心线程数，
新的核心线程数会在新任务到来时修改。
减少线程时，若当前线程数量大于新的核心线程，多的线程会等到空闲时才回收

---
### 11. Java创建多线程
1. 实现Runnable接口的run()方法，使用Thread类构造函数传入Runnable对象
2. 继承Thread类, 重写run()方法，创建Thread子类对象并
3. 实现Callable接口的call()方法，使用FutureTask包装Callable对象
4. 通过线程池ExecutorService提交Runnable和Callable任务
5. 使用CompletableFuture进行异步任务调用
---
### 12. RabbitMQ实现延迟队列
RabbitMQ本身不支持延迟队列
1. 使用TTL + 死信队列，不给延迟队列消费者，当消息在原队列达到TTL后，还未消费会被转发到死信交换器，消费者从死信队列消费消息，实现延迟处理。
2. 利用延迟消息插件，安装插件后，在发送消息时可以直接指定消息延迟时间，RabbitMQ会在消息达到延迟时间后转发消息到对应队列消费。
---
### 13. 如果Redis内存溢出，应当如何做
第一时间止损，立即增加redis实例的内存
排查原因:
1. Redis数据多，超过了可用内存
2. 数据过期策略失败，key没有设置过期时间，占用内存
3. key关联的数据结构过大
4. RDB持久化采用写时复制，占用内存
解决方案:
1. 根据需求调整内存淘汰策略
2. 对数据设置合理的过期时间
3. 优化数据结构，拆分大型数据
4. 升级单台Redis配置
5. 将数据分片到多个Redis实例，使用集群或分布式
6. 优化数据持久化策略，减少内存消耗
---
### 14. 分析JVM当前的内存占用情况，OOM后怎么分析
利用Jstat监控和分析JVM内部的垃圾回收，内存等运行状态
使用jmap查看JVM堆的详细信息
发生OOM时可以根据jmap得到堆转储文件，导入GCeasy工具中分析，找出占用大的对象，定位到具体代码解决问题

---
### 15. Dubbo和SpringCloudGateway区别
1. Dubbo是一个RPC框架，主要用于服务之间的通信，提供高性能的rpc调用，负载均衡，服务注册，服务发现等功能，用于内部服务通信
2. spring cloud gateway是一个api网关，用于处理将外部的请求路由到后端服务，提供负载均衡，安全管理，流量控制，日志等功能，用于外部请求的入口
二者不是一个层级

---
### 16. 什么是API网关，作用
API网关是客户端和后端之间的中间件，充当所有客户端请求的统一入口
作用:
1. API网关提供单一入口，客户端只需与网关交互，不需要了解接口细节
2. 将多个请求合并为一个，减少请求次数，提高性能
3. 可以对进入的请求进行身份验证
4. 隐藏了后端服务的结构，增加了安全性
5. 对不同服务之间的请求负载均衡
6. 实现限流、熔断和降级，流量激增时保护后端服务
7. 可与缓存高频访问的接口，减少后端服务压力
---
### 17. 设计秒杀功能
需求:
1. 瞬时流量的承接
2. 防止超卖
3. 预防黑产
4. 避免对正常服务的影响
5. 兜底方案
设计:
后端:
1. nginx做统一接入，负载均衡
2. 利用sentinel做流量控制，熔断降级处理
3. 将秒杀服务拆分成独立模块，独立维护
4. 增加验证信息，防止脚本抢购
5. 减扣库存加锁，加入消息中间件，redis，保证精准扣减
6. 加入最终兜底方案，关闭秒杀功能，及时止损
---
### 18. 线上CPU飙高如何排查
1. 首先利用top命令查看哪个进程占用CPU过高
2. 确认利用率高的进程pid，再根据pid查看具体线程信息
3. 再利用jstask查看具体栈信息
4. 根据栈信息定位导致CPU飙高的代码
---
### 19. RocketMQ不适应Zookeeper作为注册中心，自己实现NameServer的原因
1. RocketMQ的NameServer设计相对简单，比起Zookeeper更易于部署维护
2. NameServer无状态，多个实例间是对等的，可以通过DNS负载均衡，天然高可用
3. NameServer只负责简单的配置和路由中心，不负责状态同步，性能高
4. NameServer可以降低外部系统依赖，减少维护复杂度
5. NameServer可以更好地实现定制化需求
---
### 20. Netty如何解决JDK NIO中的空轮询bug
netty会统计空轮询的次数，到达阈值时重新构建一个Selector, 将注册的Channel移到一个新的Selector上，这一过程会取消旧的Selector注册，关闭旧的Selector
netty只是绕开了空轮询问题，没有解决

---
### 21. Netty采用了哪些设计模式
1. 策略模式
2. 单例模式
3. 工厂模式
4. 责任链模式
5. 建造者模式
---
### 22. Netty如何解决粘包和拆包
1. 分隔符解码器，使用特定分隔符分割消息
2. 固定长度解码器，按照指定长度拆分消息
3. 根据接收到的消息的长度实现消息的动态且分解码
4. 数据包之间使用换行符切割
5. 复杂场景下的自定义解码器
---
### 23. Netty高性能的原因
1. 使用了Reactor模型，充分发挥系统资源优势
2. 非阻塞I/O模型，IO都是异步非阻塞的，并且还利用了多路复用，使资源得到充分利用
3. Netty的ByteBuf提供了内存池分配和复用内存的技术，减少内存分配的频率
4. 零拷贝技术。
---
### 24.为什么不选择使用NIO，而是Netty
Netty的优势
1. 封装了NIO的复杂API，提供了简单直接的接口
2. Netty提供了优化多线程的模型，更高效地处理I/O事件，提升并发处理能力
3. Netty支持多种协议，自带编码器，解决了粘包、拆包问题
4. Netty避免了空轮询的Bug问题
5. 采用了零拷贝机制，避免了不必要的拷贝，提升性能
---
### 25. 什么情况下不推荐为数据库建立索引
1. 对于数据量很小的表
2. 频繁更新的表
3. 执行大量Select *
4. 区分度不大的列
5. 低频查询的列
6. 长文本字段
---
### 26. 说说零拷贝机制
1. 使用CompositeByteBuf减少数据拼接的拷贝
2. 使用Direct Buffer减少堆内外的拷贝
3. 使用FileRegion减少文件从内核态到用户态的拷贝
4. 通过MapperByteBuffer将文件映射到内存中直接读写数据，无需复制
--- 
### 27. 介绍Reactor线程模型
Reactor使一种编程模式，基于Selector的线程死循环监控I/O事件，每个事件安排回调函数
1. 单Reactor单线程模型：所有操作由一个I/O线程处理
2. 单Reactor多线程模型: 一个线程负责接收事件和连接I/O处理，线程池处理具体业务
3. 主从Reactor多线程模型: 主Reactor线程负责接收连接事件，从Reactor线程负责后续I/O处理，线程池处理业务逻辑
---
### 28. Netty的应用场景
1. RocketMQ、Dubbo、ElasticSearch等框架的底层通信实现
2. 游戏服务器开发中，Netty用于处理大量并发的客户端连接
3. 实现通讯系统，处理高并发的实时消息传输
4. 在物联网场景，Netty用于设备和服务器之间的通信
---
### 29. 常见的I/O模型
1. 同步阻塞I/O，调用read时，如果数据还未到来，线程会一直阻塞等待
2. 同步非阻塞I/O, read调用若无数据则立即返回错误状态，不会阻塞线程
3. I/O多路复用，一个线程使用系统调用，监控多个状态，某连接数据就绪才通知程序读取
4. 信号驱动I/O，由内核在数据就绪时通知应用程序，应用程序收到信号后调用read, 过程会阻塞
5. 异步I/O，调用aio_read后，内核负责将数据从网卡拷贝到用户空间，完成后通知应用程序，无阻塞
---
### 30. RabbitMQ消息中什么时候进入死信交换机
1. 消费者使用basic.reject或basic.nack明确拒绝消息，不要求重新投递
2. RabbitMQ为消息队列设置TTL，当消息超过该TTL后还未消费
3. 队列设置了最大长度，消息总量超出限制，最早进入队列的消息会进入死信交换机
---
### 31. RabbitMQ中无法路由的消息会去到哪里
1. 默认情况下，若无符合条件的队列，RabbitMQ会直接丢弃消息
2. 可以配置备份交换机，无法背路由的消息会被送进去，由备份交换机决定如何处理
3. 在使用mandatory参数情况下，消息无法路由，会触发回退，退回给生产者
---
### 32. 责任链模式及其应用场景
责任链模式是将请求的处理对象连成一条链，请求在链上传递，直到有对象处理它
应用场景: 事件处理系统，审批流程，日志系统

---
### 33. kafka抛弃Zookeeper的原因
1. kafka和zookeeper之间的协调增加了复杂度和运维成本，带来额外开销
2. Zookeeper写入能力有限，Kafka集群规模增大，读写操作会对Zookeeper造成压力，对kafka扩展性造成瓶颈
3. 去掉Zookeeper后，kafka只需要维护自身的节点和协议，简化了运维流程
---
### 34. kafka中zookeeper作用
1. Zookeeper负责管理kafka集群中broker的注册、状态监控
2. 当分区的Leader副本故障时，Zookeeper协调副本的选举，为分区选出新Leader
3. 早期版本kafka中，消费者的Offset存储在Zookeeper中，由Zookeeper管理
4. Zookeeper保存着Kafka的配置信息，当集群变化，Zookeeper负责负载均衡
---
### 35. 观察者模式及其应用场景
定义对象间的一对多依赖关系，当一个对象发生改变后，通知并更新所有依赖它的对象
应用场景:
作者更新作品时，推送给所有的订阅者

---
### 36. 什么是限流？为什么要限流，如何实现
限流是限制达到系统的并发请求数，使系统能够正常处理部分用户请求，保证系统稳定性
后端处理能力有限，需要截掉超过处理能力的请求，均衡客户端对服务端资源的调用
常见的限流算法
固定窗口限流、滑动窗口限流、漏桶算法、令牌桶算法

---
### 37. 简述MyBatis的插件运行原理
Mybatis的插件是通过动态代理实现的，在SQL执行的关键点进行拦截并增强功能
拦截点:
1. Executor: 负责执行增删改查操作
2. ParameterHandler: 负责处理SQL语句中的参数
3. ResultSetHandler: 负责处理结果集
4. StatementHandler: 负责处理SQL语句
   
编写一个插件:
1. 实现interceptor接口
2. 在interceptor中编写具体逻辑
3. 在mybatis-config中编写注册插件
---
### 38. kafka中关于事务消息的实现
1. 事务性生产者向事务协调器请求启动事务
2. 生产者向kafka写入事务消息，每条消息都是唯一的，保证幂等性
3. 消息写入完成后，生产者向事务协调器发送commit或abort请求，提交或终止事务
4. 消费者可以通过设置read_committed隔离级别，仅消费已经提交的消息，保证数据一致性
---
### 39. mybatis的缓存机制
一级缓存: 
- 默认开启，生命周期与SqlSession一致，仅在同一个SqlSession生效
- 当执行提交和回滚或手动清理缓存时清空
二级缓存:
- 跨SqlSession共享
- 需要手动配置
- 生命周期与SqlSessionFactory一致
- 数据更新、插入、删除都会使相关缓存失效
- 支持定制化存储
---
### 40. RocketMQ中关于事务消息的实现
1. 第一阶段消息发送:
   - 生产者将消息发送到RocketMQ的Topic，此时消息为半消息，消费者不可见
   - 生产者执行事务逻辑，根据本地事务执行结果决定操作
2. 第二阶段提交或回滚
   - 若本地事务成功，则生产者会向RocketMQ提交Commit操作，此时半消息变为正式消息，消费者可见
   - 若本地事务失败，则生产者会向RocketMQ提交Rollback操作，RocketMQ会丢弃半消息
   - 生产者未及时提交或回滚，RocketMQ会定时回查生产者本地事务状态，决定消息提交或回滚
---
### 41. RocketMQ的事务消息有什么缺点
1. 改造成本较大，需要在原逻辑上改造接口，定义回查逻辑保证不重复或丢失
2. RocketMQ仅支持单事务消息
3. 若MQ集群挂了，事务就无法进行了，整个应用也因此无法执行了
---
### 42. 消息队列的推消息和拉消息
1. 推消息是将消息主动推送给消费者，适合实时性高的场景，但难以控制消费速度，高并发时容易导致消费者过载
2. 拉消息时消费者主动从消息队列中拉取消息，适合消费能力有限的场景，但可能会造成消息延迟
---
### 43. 如何保证消息有序性
1. 单一消费者和单一生产者，使用单个生产者发送消息到单个队列，并由单个消费者处理，但容易性能瓶颈
2. 在支持分区的消息队列中，可以将消息发送到特定分区，每个分区有序
3. 在支持顺序队列的消息队列中，消息在队列中的存储顺序与投递顺序一致
---
### 44. 处理重复消息
让消费者的逻辑处理具有幂等性，无论同一条消息被消费了多少次，结果始终一样

---
### 45. 保证消息不丢失
1. 生产者的消息确认: 生产者在发送消息时，需要通过消息确认机制保证消息到达
2. broker收到消息后，需要将消息持久化到磁盘上，避免因为内存丢失
3. 消费者处理完消息后，再次向消费队列发送确认，若消费者未发送，消费队列要重新投递该消息
---
### 46. 工厂模式和抽象工厂模式的区别
1. 工厂模式关注单一类型对象，定义一个抽象方法，由子类实现具体对象实例化
2. 抽象工厂模式关注的是创建一组相关对象，提供一个接口来创建一组相关或相互依赖的对象，无需指定它们的具体类
---
### 47. 单例模式有哪几种实现，如何保证线程安全
饿汉式: 实例在类加载时就创建，线程安全，实例未被使用就会导致资源浪费
懒汉式: 实例在首次访问时被加载，节约资源，但需要确保线程安全
双重检查锁定: 只在第一次检查实例为空时加锁，优化懒汉式的性能
静态内部类: 利用类加载机制实现懒加载和线程安全
枚举类: Java特有，通过枚举实现单例，简单且防止反射和序列化攻击
保证线程安全:
使用静态内部类或双重检查锁定，配合volatile

---
### 48. 消息队列模型
1. 队列模型，消息从生产者发送到队列，每条消息只能被一个消费者执行一次，消费后，消息被删除
2. 发布/订阅模型，生产者将消息发送到每个主题，所有订阅了该消息的消费者都会姐都到该消息
---
### 49. 为什么需要消息队列
用来实现异步处理，服务解耦、流量控制
应用场景:
- 订单系统: 在电商系统中，订单的创建、支付、发货都可以通过消息队列进行异步处理和解耦
- 日志处理: 使用消息队列将日志从应用系统传输到日志处理系统，实时监控
- 任务调度: 通过消息队列将任务分发给多个工作节点，并行处理
- 数据同步: 消息队列可以将变更的数据异步同步到不同的存储系统
---
### 50. 设计一个分布式ID发号器
雪花算法: 生成一个64位bit的数组，前41位使用时间戳，后10位表示随机机器号，最后12位作为自增号
一般不适用uuid, 虽然方便快捷，但uuid很长且无序，若作为主键，会导致数据页频繁分裂，降低性能

---
### 51. Mybatis中 `#{}` 和 `${}` 区别
1. `#{}`用于传入SQL查询语句的参数，将参数传递给数据库查询，而不是拼接到SQL，避免了SQL注入
2. `${}`用于直接将参数值拼接到SQL语句中，不做其他任何处理。为了安全默认使用`#{}`
---
### 52. Mybatis和Hibernate
1. Hibernate时全自动ORM框架，会自动生成SQL; Mybatis是半自动ORM，需要开发者手写SQL
2. Mybatis具有更灵活的SQL定制能力，Hibernate更注重对象与数据库的映射，适合复杂实体关系模型
3. 复杂查询场景下Mybatis的性能优于Hibernate, 因为SQL可控性强
---
### 53. 分布式锁一般如何实现
1. 使用`Redis setEXNX`命令设置锁，
2. java中可以使用jedis客户端，使用acquireLock获取锁，set设置锁，releaseLock释放锁
3. 若锁过期了，可以引入看门狗机制，即后台创建定时任务，不断给锁续期
4. 若单点故障，可以使用RedLock
