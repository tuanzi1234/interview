### 1. JVM内存溢出的情况
1. 堆内存不足
2. 栈空间耗尽
3. 元空间不足
4. 直接内存不足
5. 线程数过多
6. GC时间过长
---
### 2. JVM组成部分
1. 类加载子系统
2. 运行时数据区
3. 执行引擎
4. 本地方法接口
---
### 3. MySQL中select * form 千万级别数据的表，内存会飙升吗？
不会，MySQL执行查询语句时，不会将1000w的数据加载到内存中，而是逐次批次处理的方式控制内存使用，也就是说，MySQL是边查边发数据给客户端

---
### 4. MySQL三层B+树能存多少数据
B+ 树默认数据页大小16KB
假设每个数据记录主键和数据大小为1KB
那么每个叶子节点就能存储16条数据
假设每个指针6字节，索引键一般8字节，那么每个节点可以指向16 * 1024 / (6 + 8) = 1170个叶子节点
总共三层，因此，能够存储的数据总量为1170 * 1170 * 16，大约能存储2000w条数据

---
### 5. MySQL事务的二阶段提交
指为了确保redo log(重做日志)和binlog(二进制日志)之间的一致性使用的机制
二阶段提交的两个阶段:
1. 准备阶段: MySQL的InnoDB引擎会在事务提交写入redo log, 标记状态为prepare，此时redo log是预提交状态
2. 提交阶段: 当redo log状态为prepare后，MySQL server会写入binlog，binlog写入成功后，MySQL会通知InnoDB，将redolog改为commit,完成提交
---
### 6. SpringBoot的启动流程
1. 启动main方法
2. 创建SpringApplication对象，推断应用类型、设置初始化器、监听器、主应用类
3. 准备ConfigurableEnvironment，加载配置文件、环境变量、命令行参数
4. 创建应用上下文，加载配置类，注册bean，注入依赖
5. 对于Web应用，SpringBoot会自动启动Web容器，注册Servlet和Filter
6. 对应监听stated事件逻辑会被触发
7. 启动完成后，执行CommandLineRunner和ApplicationRunner
8. 触发ApplicationReadyEvent, 应用进入运行状态，处理业务请求。
---
### 7. SpringBoot实现自动配置
通过`@EnableAutoConfiguration`注解实现，这个注解包含`@Import({AutoConfigurationImportSelector.class})`，这个类会去扫描classpath下的所有META-INF/spring.factories文件，根据文件中指定的配置类加载响应的Bean

---
### 8. Java中HashMap的原理
HashMap是基于哈希表的数据结构，用于存储键值对。
核心是将键的哈希值映射到数组索引位置。
Java8以前通过数组+链表，Java8以后改成数组+链表+红黑树处理哈希冲突。
利用hashCode()方法计算哈希值，使用`(n - 1) & hash`计算元素在数组的位置
初始容量为16，负载因子0.75，当元素超过12时就会触发扩容操作，容量 * 2重新分配元素位置

---
### 9. `Redisson`分布式锁的原理
确保多线程操作中, 只有一个线程能获得锁，避免并发操作导致的数据不一致问题
1. `redisson`使用`exist` + `hexist` + `hincrby`命令来保证只有一个线程能成功设置键，表示获得锁
   并且会通过`pexpire`命令为锁设置过期时间，防止死锁问题
2. 防止锁在持有过程中被其他线程抢占，`Redisson`有自动续期功能，持有锁的线程会定期续期，保证任务没结束锁不失效
3. 利用`hexists` + `del`确保只有持有锁的线程才能释放锁，防止误释放的情况
   Lua同时利用`publish`唤醒其他等待的进程
4. 支持重入锁，持有锁的进程可以多次获取同一把锁不阻塞。利用Redis的hash结构，key为线程id，重入则值加一，释放则值减一，0则被释放，执行del。
---
### 10. Java线程池核心线程数在运行过程中可以修改吗？
可以修改
`ThreadPoolExecutor`提供了`setCorePoolSize(int corePoolSize)`方法可以动态增加或减少核心线程数。
corePoolSize表示线程池中的核心线程数，
新的核心线程数会在新任务到来时修改。
减少线程时，若当前线程数量大于新的核心线程，多的线程会等到空闲时才回收

---
### 11. Java创建多线程
1. 实现Runnable接口的run()方法，使用Thread类构造函数传入Runnable对象
2. 继承Thread类, 重写run()方法，创建Thread子类对象
3. 实现Callable接口的call()方法，使用FutureTask包装Callable对象
4. 通过线程池ExecutorService提交Runnable和Callable任务
5. 使用CompletableFuture进行异步任务调用
---
### 12. RabbitMQ实现延迟队列
RabbitMQ本身不支持延迟队列
1. 使用TTL + 死信队列，不给延迟队列消费者，当消息在原队列达到TTL后，还未消费会被转发到死信交换器，消费者从死信队列消费消息，实现延迟处理。
2. 利用延迟消息插件，安装插件后，在发送消息时可以直接指定消息延迟时间，RabbitMQ会在消息达到延迟时间后转发消息到对应队列消费。
---
### 13. 如果Redis内存溢出，应当如何做
第一时间止损，立即增加redis实例的内存
排查原因:
1. Redis数据多，超过了可用内存
2. 数据过期策略失败，key没有设置过期时间，占用内存
3. key关联的数据结构过大
4. RDB持久化采用写时复制，占用内存
   
解决方案:
1. 根据需求调整内存淘汰策略
2. 对数据设置合理的过期时间
3. 优化数据结构，拆分大型数据
4. 升级单台Redis配置
5. 将数据分片到多个Redis实例，使用集群或分布式
6. 优化数据持久化策略，减少内存消耗
---
### 14. 分析JVM当前的内存占用情况，OOM后怎么分析
利用Jstat监控和分析JVM内部的垃圾回收，内存等运行状态
使用jmap查看JVM堆的详细信息
发生OOM时可以根据jmap得到堆转储文件，导入GCeasy工具中分析，找出占用大的对象，定位到具体代码解决问题

---
### 15. Dubbo和SpringCloudGateway区别
1. Dubbo是一个RPC框架，主要用于服务之间的通信，提供高性能的rpc调用，负载均衡，服务注册，服务发现等功能，用于内部服务通信
2. spring cloud gateway是一个api网关，用于处理将外部的请求路由到后端服务，提供负载均衡，安全管理，流量控制，日志等功能，用于外部请求的入口
二者不是一个层级

---
### 16. 什么是API网关，作用
API网关是客户端和后端之间的中间件，充当所有客户端请求的统一入口
作用:
1. API网关提供单一入口，客户端只需与网关交互，不需要了解接口细节
2. 将多个请求合并为一个，减少请求次数，提高性能
3. 可以对进入的请求进行身份验证
4. 隐藏了后端服务的结构，增加了安全性
5. 对不同服务之间的请求负载均衡
6. 实现限流、熔断和降级，流量激增时保护后端服务
7. 可以缓存高频访问的接口，减少后端服务压力
---
### 17. 设计秒杀功能
需求:
1. 瞬时流量的承接
2. 防止超卖
3. 预防黑产
4. 避免对正常服务的影响
5. 兜底方案

设计:
后端:
1. nginx做统一接入，负载均衡
2. 利用sentinel做流量控制，熔断降级处理
3. 将秒杀服务拆分成独立模块，独立维护
4. 增加验证信息，防止脚本抢购
5. 减扣库存加锁，加入消息中间件，redis，保证精准扣减
6. 加入最终兜底方案，关闭秒杀功能，及时止损
---
### 18. 线上CPU飙高如何排查
1. 首先利用top命令查看哪个进程占用CPU过高
2. 确认利用率高的进程pid，再根据pid查看具体线程信息
3. 再利用jstask查看具体栈信息
4. 根据栈信息定位导致CPU飙高的代码
---
### 19. RocketMQ不适应Zookeeper作为注册中心，自己实现NameServer的原因
1. RocketMQ的NameServer设计相对简单，比起Zookeeper更易于部署维护
2. NameServer无状态，多个实例间是对等的，可以通过DNS负载均衡，天然高可用
3. NameServer只负责简单的配置和路由中心，不负责状态同步，性能高
4. NameServer可以降低外部系统依赖，减少维护复杂度
5. NameServer可以更好地实现定制化需求
---
### 20. Netty如何解决JDK NIO中的空轮询bug
netty会统计空轮询的次数，到达阈值时重新构建一个Selector, 将注册的Channel移到一个新的Selector上，这一过程会取消旧的Selector注册，关闭旧的Selector
netty只是绕开了空轮询问题，没有解决

---
### 21. Netty采用了哪些设计模式
1. 策略模式
2. 单例模式
3. 工厂模式
4. 责任链模式
5. 建造者模式
---
### 22. Netty如何解决粘包和拆包
1. 分隔符解码器，使用特定分隔符分割消息
2. 固定长度解码器，按照指定长度拆分消息
3. 根据接收到的消息的长度实现消息的动态且分解码
4. 数据包之间使用换行符切割
5. 复杂场景下的自定义解码器
---
### 23. Netty高性能的原因
1. 使用了Reactor模型，充分发挥系统资源优势
2. 非阻塞I/O模型，IO都是异步非阻塞的，并且还利用了多路复用，使资源得到充分利用
3. Netty的ByteBuf提供了内存池分配和复用内存的技术，减少内存分配的频率
4. 零拷贝技术。
---
### 24.为什么不选择使用NIO，而是Netty
Netty的优势
1. 封装了NIO的复杂API，提供了简单直接的接口
2. Netty提供了优化多线程的模型，更高效地处理I/O事件，提升并发处理能力
3. Netty支持多种协议，自带编码器，解决了粘包、拆包问题
4. Netty避免了空轮询的Bug问题
5. 采用了零拷贝机制，避免了不必要的拷贝，提升性能
---
### 25. 什么情况下不推荐为数据库建立索引
1. 对于数据量很小的表
2. 频繁更新的表
3. 执行大量Select *
4. 区分度不大的列
5. 低频查询的列
6. 长文本字段
---
### 26. 说说零拷贝机制
1. 使用CompositeByteBuf减少数据拼接的拷贝
2. 使用Direct Buffer减少堆内外的拷贝
3. 使用FileRegion减少文件从内核态到用户态的拷贝
4. 通过MapperByteBuffer将文件映射到内存中直接读写数据，无需复制
--- 
### 27. 介绍Reactor线程模型
Reactor使一种编程模式，基于Selector的线程死循环监控I/O事件，每个事件安排回调函数
1. 单Reactor单线程模型：所有操作由一个I/O线程处理
2. 单Reactor多线程模型: 一个线程负责接收事件和连接I/O处理，线程池处理具体业务
3. 主从Reactor多线程模型: 主Reactor线程负责接收连接事件，从Reactor线程负责后续I/O处理，线程池处理业务逻辑
---
### 28. Netty的应用场景
1. RocketMQ、Dubbo、ElasticSearch等框架的底层通信实现
2. 游戏服务器开发中，Netty用于处理大量并发的客户端连接
3. 实现通讯系统，处理高并发的实时消息传输
4. 在物联网场景，Netty用于设备和服务器之间的通信
---
### 29. 常见的I/O模型
1. 同步阻塞I/O，调用read时，如果数据还未到来，线程会一直阻塞等待
2. 同步非阻塞I/O, read调用若无数据则立即返回错误状态，不会阻塞线程
3. I/O多路复用，一个线程使用系统调用，监控多个状态，某连接数据就绪才通知程序读取
4. 信号驱动I/O，由内核在数据就绪时通知应用程序，应用程序收到信号后调用read, 过程会阻塞
5. 异步I/O，调用aio_read后，内核负责将数据从网卡拷贝到用户空间，完成后通知应用程序，无阻塞
---
### 30. RabbitMQ消息中什么时候进入死信交换机
1. 消费者使用basic.reject或basic.nack明确拒绝消息，不要求重新投递
2. RabbitMQ为消息队列设置TTL，当消息超过该TTL后还未消费
3. 队列设置了最大长度，消息总量超出限制，最早进入队列的消息会进入死信交换机
---
### 31. RabbitMQ中无法路由的消息会去到哪里
1. 默认情况下，若无符合条件的队列，RabbitMQ会直接丢弃消息
2. 可以配置备份交换机，无法被路由的消息会被送进去，由备份交换机决定如何处理
3. 在使用mandatory参数情况下，消息无法路由，会触发回退，退回给生产者
---
### 32. 责任链模式及其应用场景
责任链模式是将请求的处理对象连成一条链，请求在链上传递，直到有对象处理它
应用场景: 事件处理系统，审批流程，日志系统

---
### 33. kafka抛弃Zookeeper的原因
1. kafka和zookeeper之间的协调增加了复杂度和运维成本，带来额外开销
2. Zookeeper写入能力有限，Kafka集群规模增大，读写操作会对Zookeeper造成压力，对kafka扩展性造成瓶颈
3. 去掉Zookeeper后，kafka只需要维护自身的节点和协议，简化了运维流程
---
### 34. kafka中zookeeper作用
1. Zookeeper负责管理kafka集群中broker的注册、状态监控
2. 当分区的Leader副本故障时，Zookeeper协调副本的选举，为分区选出新Leader
3. 早期版本kafka中，消费者的Offset存储在Zookeeper中，由Zookeeper管理
4. Zookeeper保存着Kafka的配置信息，当集群变化，Zookeeper负责负载均衡
---
### 35. 观察者模式及其应用场景
定义对象间的一对多依赖关系，当一个对象发生改变后，通知并更新所有依赖它的对象
应用场景:
作者更新作品时，推送给所有的订阅者

---
### 36. 什么是限流？为什么要限流，如何实现
限流是限制达到系统的并发请求数，使系统能够正常处理部分用户请求，保证系统稳定性
后端处理能力有限，需要截掉超过处理能力的请求，均衡客户端对服务端资源的调用
常见的限流算法
固定窗口限流、滑动窗口限流、漏桶算法、令牌桶算法

---
### 37. 简述MyBatis的插件运行原理
Mybatis的插件是通过动态代理实现的，在SQL执行的关键点进行拦截并增强功能
拦截点:
1. Executor: 负责执行增删改查操作
2. ParameterHandler: 负责处理SQL语句中的参数
3. ResultSetHandler: 负责处理结果集
4. StatementHandler: 负责处理SQL语句
   
编写一个插件:
1. 实现interceptor接口
2. 在interceptor中编写具体逻辑
3. 在mybatis-config中编写注册插件
---
### 38. kafka中关于事务消息的实现
1. 事务性生产者向事务协调器请求启动事务
2. 生产者向kafka写入事务消息，每条消息都是唯一的，保证幂等性
3. 消息写入完成后，生产者向事务协调器发送commit或abort请求，提交或终止事务
4. 消费者可以通过设置read_committed隔离级别，仅消费已经提交的消息，保证数据一致性
---
### 39. mybatis的缓存机制
一级缓存: 
- 默认开启，生命周期与SqlSession一致，仅在同一个SqlSession生效
- 当执行提交和回滚或手动清理缓存时清空
  
二级缓存:
- 跨SqlSession共享
- 需要手动配置
- 生命周期与SqlSessionFactory一致
- 数据更新、插入、删除都会使相关缓存失效
- 支持定制化存储
---
### 40. RocketMQ中关于事务消息的实现
1. 第一阶段消息发送:
   - 生产者将消息发送到RocketMQ的Topic，此时消息为半消息，消费者不可见
   - 生产者执行事务逻辑，根据本地事务执行结果决定操作
2. 第二阶段提交或回滚
   - 若本地事务成功，则生产者会向RocketMQ提交Commit操作，此时半消息变为正式消息，消费者可见
   - 若本地事务失败，则生产者会向RocketMQ提交Rollback操作，RocketMQ会丢弃半消息
   - 生产者未及时提交或回滚，RocketMQ会定时回查生产者本地事务状态，决定消息提交或回滚
---
### 41. RocketMQ的事务消息有什么缺点
1. 改造成本较大，需要在原逻辑上改造接口，定义回查逻辑保证不重复或丢失
2. RocketMQ仅支持单事务消息
3. 若MQ集群挂了，事务就无法进行了，整个应用也因此无法执行了
---
### 42. 消息队列的推消息和拉消息
1. 推消息是将消息主动推送给消费者，适合实时性高的场景，但难以控制消费速度，高并发时容易导致消费者过载
2. 拉消息时消费者主动从消息队列中拉取消息，适合消费能力有限的场景，但可能会造成消息延迟
---
### 43. 如何保证消息有序性
1. 单一消费者和单一生产者，使用单个生产者发送消息到单个队列，并由单个消费者处理，但容易性能瓶颈
2. 在支持分区的消息队列中，可以将消息发送到特定分区，每个分区有序
3. 在支持顺序队列的消息队列中，消息在队列中的存储顺序与投递顺序一致
---
### 44. 处理重复消息
让消费者的逻辑处理具有幂等性，无论同一条消息被消费了多少次，结果始终一样

---
### 45. 保证消息不丢失
1. 生产者的消息确认: 生产者在发送消息时，需要通过消息确认机制保证消息到达
2. broker收到消息后，需要将消息持久化到磁盘上，避免因为内存丢失
3. 消费者处理完消息后，再次向消费队列发送确认，若消费者未发送，消费队列要重新投递该消息
---
### 46. 工厂模式和抽象工厂模式的区别
1. 工厂模式关注单一类型对象，定义一个抽象方法，由子类实现具体对象实例化
2. 抽象工厂模式关注的是创建一组相关对象，提供一个接口来创建一组相关或相互依赖的对象，无需指定它们的具体类
---
### 47. 单例模式有哪几种实现，如何保证线程安全
饿汉式: 实例在类加载时就创建，线程安全，实例未被使用就会导致资源浪费
懒汉式: 实例在首次访问时被加载，节约资源，但需要确保线程安全
双重检查锁定: 只在第一次检查实例为空时加锁，优化懒汉式的性能
静态内部类: 利用类加载机制实现懒加载和线程安全
枚举类: Java特有，通过枚举实现单例，简单且防止反射和序列化攻击
保证线程安全:
使用静态内部类或双重检查锁定，配合volatile

---
### 48. 消息队列模型
1. 队列模型，消息从生产者发送到队列，每条消息只能被一个消费者执行一次，消费后，消息被删除
2. 发布/订阅模型，生产者将消息发送到每个主题，所有订阅了该消息的消费者都会接收到该消息
---
### 49. 为什么需要消息队列
用来实现异步处理，服务解耦、流量控制
应用场景:
- 订单系统: 在电商系统中，订单的创建、支付、发货都可以通过消息队列进行异步处理和解耦
- 日志处理: 使用消息队列将日志从应用系统传输到日志处理系统，实时监控
- 任务调度: 通过消息队列将任务分发给多个工作节点，并行处理
- 数据同步: 消息队列可以将变更的数据异步同步到不同的存储系统
---
### 50. 设计一个分布式ID发号器
雪花算法: 生成一个64位bit的数组，前41位使用时间戳，后10位表示随机机器号，最后12位作为自增号
一般不适用uuid, 虽然方便快捷，但uuid很长且无序，若作为主键，会导致数据页频繁分裂，降低性能

---
### 51. Mybatis中 `#{}` 和 `${}` 区别
1. `#{}`用于传入SQL查询语句的参数，将参数传递给数据库查询，而不是拼接到SQL，避免了SQL注入
2. `${}`用于直接将参数值拼接到SQL语句中，不做其他任何处理。为了安全默认使用`#{}`
---
### 52. Mybatis和Hibernate
1. Hibernate时全自动ORM框架，会自动生成SQL; Mybatis是半自动ORM，需要开发者手写SQL
2. Mybatis具有更灵活的SQL定制能力，Hibernate更注重对象与数据库的映射，适合复杂实体关系模型
3. 复杂查询场景下Mybatis的性能优于Hibernate, 因为SQL可控性强
---
### 53. 分布式锁一般如何实现
1. 使用`Redis setEXNX`命令设置锁，
2. java中可以使用jedis客户端，使用acquireLock获取锁，set设置锁，releaseLock释放锁
3. 若锁过期了，可以引入看门狗机制，即后台创建定时任务，不断给锁续期
4. 若单点故障，可以使用RedLock
---
### 54. 服务熔断
当服务器的某个服务调用失败率持续升高时，通过终止对该服务的请求，防止系统资源被不断消耗，进而保证整个系统不受影响。

---
### 55. 服务降级
服务降级时一种分布式系统和微服务架构中的容错机制，用于在系统压力过大时，暂时关闭不必要的功能，确保核心功能的正常运行

---
### 56. 服务雪崩
服务雪崩是指在微服务架构和分布式系统中，由于某个服务不可用或性能下降，导致依赖它的其他服务也因此连锁故障，最终导致整个系统或大部分服务不可用的现象

---
### 57. HTTP和RPC的区别
HTTP和RPC不是一个层级的东西
- HTTP是应用层的协议，强调网络通信
- RPC是分布式系统之间通信的一种方式，强调服务的远程调用
---
### 58. 负载均衡算法
1. 轮询算法: 按照顺序将请求分发给后端服务器
2. 加权算法: 在轮询算法的基础上给服务器加上权重，权重越高，被选中的概率越大
3. 随机算法: 将请求随机发给后端服务器
4. 加权随机: 在随机算法的请求上给服务器加上权重
5. 最少连接: 连接最少的服务器会被选上
6. 哈希算法: 根据URL, IP等来计算哈希值，根据哈希值选择服务器
---
### 59. 分布式和微服务的区别
1. 分布式系统是有多个节点组成的系统，通过网络进行通信协作，共同完成一个或多个共享任务
2. 微服务是将一个大而全的服务，拆分成多个独立、松耦合的服务单元，为了让这些单元可以独立部署、运行、管理
---
### 60. 什么是seata
一款分布式事务的解决方案，为了解决全局事务的一致性问题
有三个重要的角色
1. 事务协调者(TC): 对全局的分支事务进行注册，根据各个事务的状态决定提交或回滚
2. 事务管理者(TM): 根据业务逻辑决定是否开启一个新事务，并根据情况进行提交或回滚操作
3. 资源管理器(RM): 向TC注册分支事务，上报分支事务状态，接收TC的命令传达给TM是否提交或回滚
---
### 61. 如何理解SpringBoot的starter
Starter是一组依赖集合，用于简化配置。
SpringBoot通过StarterPOMs提供了各种常用功能模块的集成，开发者只需要引入一个Starter依赖，便可以自动获得该模块所有的相关依赖和配置，无需手动添加多个依赖库和配置文件

---
### 62. 什么情况下需要分布式事务，有哪些方案
跨多个数据库、或者不同服务的情况下需要用到分布式事务来保证数据一致性
方案:
- 2PC: 协调者管理全局事务，所有参与的资源管理器在第一阶段准备事务，第二阶段提交事务
- 3PC: 比2PC多了一个询问阶段，分别是准备、预提交和提交三个阶段，为了解决2PC同步阻塞的情况
- TCC: 将事务拆分为Try预留资源、Confirm实际提交、Cancel回滚三个步骤，需要由业务自己实现
- 本地消息: 每个参与的子事务设计为独立的本地事务，通过状态表记录，采用定时任务来检查或补偿
- 事务消息: 通过消息中间件，将业务操作和消息发送绑定，接收方处理消息时保证消息消费与业务操作一致
---
### 63. Spring的启动过程
1. 加载配置文件，初始化容器
2. 实例化Spring容器
3. 解析声明的Bean的数据、作用域、依赖等信息
4. 实例化Bean
5. 注入依赖
6. 处理Bean生命周期初始化方法
7. 处理BeanPostProcessors，生成SpringAOP代理
8. 发布事件
9. 完成启动
---
### 64. SpringBoot如何通过main方法启动web项目
1. 通过SpringApplication.run()创建Spring应用上下文，执行自动配置
2. 创建应用上下文
3. 启动内嵌的Web服务器
4. 通过`@EnableAutoConfiguration`自动配置各种组件
5. 处理http请求
---
### 65. SpringBoot核心特性
1. 内嵌服务器，不需要手动配置Tomcat
2. 自动化配置
3. 支持jar包运行，只要有java环境就能运行web容器
4. 完整的生态支持
5. 支持开发者监控应用的运行状态
---
### 66. 什么是SpringBoot
SpringBoot是一个简化Spring应用程序开发的框架，主要目标是减少Spring应用程序的配置和开发复杂性，使我们能够更快构建、测试、部署spring应用

---
### 67. 设计一个短链系统
1. 原理: 浏览器输入短链，短链服务会根据Url找到对应的长链，重定向到长链地址，此时浏览器就会跳转网页定位到真正的地址
2. 设计:
   首先生成短链
   - 然后通过数据库的自增id作为短链，往数据库插入长链，这样就得到了短链id
     当访问xxx/1 时就会定位到数据库记录
     缺点是当短链数量变多，自增id就会变得很大，短链就不短了
   - 可以通过hash算法将长链进行hash运算，得到固定长度的数据，之后若短链函数很长，还可以进一步对其进行进制转化
   
   重定向，输入短链后，服务器返回301，或302状态码，然后在location上写长链地址，浏览器会自动识别跳转
---
### 68. 设计一个RPC框架
1. 动态代理：屏蔽底层调用细节
2. 序列化，网络数据传输层需扁平的数据
3. 协议，协议规定，才能识别数据
4. 网络传输，用netty做底层通信框架
---
### 69. 什么是配置中心，常见的配置中心
用于集中化管理且支持动态刷新、分发配置文件的工具
常见配置中心:
- Spring Cloud Config: 支持Git，SVN等版本控制系统加载配置
- Apollo: 支持配置的实时推送和权限管理
- Nacos: 既支持配置中心，又作为注册中心
- Zookeeper: 作用同Nacos
---
### 70. 线上发现Redis集群爆了，如何优化
1. 排查原因
2. 若内存耗尽，则需要立刻增加内存量，临时解决线上问题
   后续追查代码，判断数据大小、过期时间等原因
3. 如果是CPU使用率飙升，可能是因为读写请求太多，或者复杂度太高
4. 如果是带宽方面，则需要增加带宽配置，加大带宽
---
### 71. 物理地址、逻辑地址是什么
1. 物理地址是计算机内存中的内存单元地址，数据在物理内存中实际的存储位置，由硬件决定
2. 虚拟地址，又叫逻辑地址，运行时看到的地址空间，由cpu生成，由操作系统通过地址转换机制映射到物理地址
---
### 72. Select、Poll、Epoll区别
- Select, 使用固定长度数组表示文件描述符，支持的文件描述符数量有限，大规模连接场景效率低
- poll, 使用动态数组存储文件描述符，但每次调用需要遍历全部描述符，大规模连接场景下效率不高
- epoll, 调用时不会遍历所有文件描述符，只处理变化的描述符，适合高并发场景
---
### 73. redis性能瓶颈如何处理
1. 扩容，增加redis配置
2. 上redis主从，通过从服务分担压力，哨兵负责故障转移
3. 利用redis集群进行数据分片
4. 增加本地内存，多级缓存分担压力
---
### 74. 常见的redis客户端
1. Jedis 适用于简单的同步操作和单线程环境
2. Lettuce 适用于高并发、高性能、多线程的环境
3. Redisson 适用于复杂的分布式系统，提供丰富的分布式对象和服务，简化开发
---
### 75. 使用Redis快速实现布隆过滤器
布隆过滤器用于检测一个元素是否在一个集合中，用于解决缓存穿透问题
实现方法:
1. 使用redis的位图结构`SETBIT`和`GETBIT`实现布隆过滤器，位图本质上是比特数组，标记文件是否存在
2. 使用RedisBloom，可以直接用于创建和管理布隆过滤器，使用`BF.ADD`向布隆过滤器添加元素，`BF.EXISTS`查看元素是否存在
---
### 76. Redis实现快速排行
1. 使用Redis的`ZADD`命令，将用户和对应分数加入有序集合中
2. 使用`ZRANK`命令获取某个用户排名。
3. 使用`ZREVRANGE`命令获取分数最高的前N名。
4. 如果有分数需要更新，可以使用`ZINCRBY`命令对齐分数进行加减操作
---
### 77.Redis中如何保证缓存和数据库数据一致
1. 先更新缓存，再更新数据库
2. 先更新数据库，在更新缓存
3. 先删除缓存，再更新数据库，后续查询把数据库的数据存回缓存
4. 先更新数据库，再删除缓存，后续等查询把数据库的数据存回缓存
5. 更新数据库，前删除一次缓存，更新完成后，再延迟删除
6. 使用Binlog异步更新缓存，监听数据库Binlog变化，通过异步方式更新redis缓存
---
### 78. 缓存击穿、缓存穿透、缓存雪崩是什么
1. 缓存击穿，指某个热点数据缓存失效，大量请求直接访问数据库，顺势高并发可能使数据库崩溃。
   使用互斥锁，确保同一时间只有一个请求去数据库查询更新缓存，设置热点数据永不过期。
2. 缓存穿透，指查询某个不存在的数据，缓存中没有记录，每次请求都去数据库，加重负担。
   使用布隆过滤器，过滤不存在的请求；对不存在的数据也设置一个缓存标识。
3. 缓存雪崩，指多个缓存数据在同一时间过期，大量请求同时访问数据库，增加负载。
   采用随机过期策略，避免多个数据同时过期；将数据存储在两层缓存中
---
### 79. Redis实现分布式锁可能遇到的问题
1. 业务未执行完，锁已到期
2. 单点故障问题
3. 主从问题不同步问题
4. 网络分区问题
5. 时钟漂移问题
6. 锁的可重入性问题
7. 误释放锁的问题
---
### 80. Redis中如何实现分布式锁
常见方法是通过`set ex nx`命令和lua脚本组合使用，确保多个客户端不会获得同一个资源锁，保证了安全解锁和意外情况下锁的自动释放

---
### 81. Redis集群的脑裂问题
Redis存在脑裂问题，在网络分区的情况下，可能会导致同一集群内出现多个主节点，导致数据不一致

---
### 82. Redis集群的实现原理
Redis集群是通过由多个redis实例组成的，每个实例存储部分的数据
具体是采用Hash slot机制分配数据，将整个键空间拆分为16384个槽，每个redis实例负责一定范围哈希槽，数据的key通过哈希函数计算后对16384取余定位到对应节点。
客户端发送请求时，会通过集群任意节点连接，如果该节点有对应数据则返回，反之则将请求路由到正确节点。

---
### 83. Redis主从复制实现的原理
主从复制时redis实例主节点可以将数据复制到多个从节点，主从节点数据保证同步
复制过程:
1. 从节点通过向主节点发送`PSYNC`命令发起同步
2. 如果第一次连接，或之前连接失败，会触发全量复制，主节点将当前数据快照(RDB文件)发送给从节点
3. 全量复制完毕后，主从间会保持长连接，后续的写操作都会通过这个连接执行，保证数据一致
---
### 84. Redis的哨兵机制是什么
用于监控redis的主从集群，自动完成主从切换，实现故障的自动回复和通知
主要功能:
1. 不断监控主从节点的运行状态，定期发送PING检查连接
2. 主节点发生故障时，哨兵会选举一个从节点提升为新的主节点，通知客户端更新主节点地址
3. 哨兵可以向管理员或其他服务发送通知，快速处理redis实例的状态变化
---
### 85. Redis在生成RDB文件时如何处理请求
Redis生成RDB文件时是异步的，采用了fork子进程的方式进行快照操作，生成RDB文件的过程由子进程完成，主进程继续处理客户端请求，二者互不影响。

---
### 86. Redis持久化机制有哪些
1. RDB快照: 通过生成某一时刻的数据快照实现持久化，适合灾难恢复和备份，但可能在崩溃时丢失最后一次快照数据
2. AOF日志: 通过将每个写操作追加到日志文件中实现持久化，数据恢复更精确，但文件体积大，重写时耗费资源更多
---
### 87. 解决Redis中热点key的问题
热点key是指某些key被频繁访问，导致redis压力过大，进而影响整体性能
解决方法:
1. 将热点数据拆分到多个key中，例如引入随机前缀，使请求分散，避免集中访问一个key
2. 在redis前增加其他缓存层，分担redis压力
3. 通过主从复制，将读请求分发到从节点，减轻单节点压力
4. 采用限流策略，减少对热点key的请求，必要时返回降级数据
---
### 88. redis的big key问题是什么？怎么解决
指某个key占用了较大的内存空间
导致的问题:
1. 如果大key都映射到一个实例，则分布不均，影响查询效率
2. redis单线程执行命令，操作大key耗时长，会导致其他命令阻塞，可能会导致客户端请求超时
3. 大key对资源的占用大，导致获取时产生的流量波动大

解决方案:
1. 对数据进行压缩后再存储
2. 将大key拆分成多个小key，降低单个key的内存大小
3. 根据实际情况只存储必要数据，不常用数据则不储存
4. 优化业务逻辑，直接移除不展示的信息
5. 采用集群方式进行redis部署，大key拆分到不同服务器
---
### 89. redis的pipline功能
允许客户端在一次网络请求中批量发送多个命令，减少网络延迟提高性能。
节省了网络传输时间，减少了redis服务端上下文切换的开销

---
### 90. Redis的lua脚本功能是什么？
允许用户在redis的服务器端执行自定义的Lua脚本
通过在服务器端执行脚本减少了客户端和服务器端的网络往返次数，提升性能
可以在lua脚本中执行复杂逻辑，超过了单个redis命令的能力
lua脚本本身没有原子性，但redis单线程执行，将lua脚本作为命令执行，阻塞期间接收的其他命令，保证了原子性，避免了并发修改。

---
### 91. Redis的内存淘汰策略
- noeviction: 默认不淘汰数据，运行内存超过最大设置内存后，直接返回报错禁止写入
- volatile-random: 随机淘汰过期时间的key
- volatile-ttl: 优先淘汰较早过期的key
- volatile-lru: 淘汰掉设置过期时间且最久未使用的key
- volatile-lfu: 与lru类似，不过是淘汰最少使用的key
- allkeys-random: 随机淘汰任意key
- allkeys-lru: 淘汰缓存中最久没用的key
- allkeys-lfu: 淘汰缓存中使用最少的key
---
### 92. redis数据过期后删除策略
- 定期删除: 默认每隔100ms会随机删除一定数量的key，若有过期键，则将其删除，防止内存膨胀
- 惰性删除: 每次访问key时，redis会检查key是否过期，若过期则删除。在不访问时对过期键不立即删除
---
### 93. redis支持事务吗? 如何实现
实现流程:
1. 使用`MULTI`开始一个事务，之后的命令会被排队
2. 在事务中添加命令，命令会被存储进队列中，不会立刻执行
3. 使用`EXEC`命令执行队列中的命令，确保原子性
4. 使用`DISCARD`命令可以放弃事务清空队列
5. 使用`WATCH`可以监视一个或多个key，若事务执行前key被修改则`EXEC`不被执行，确保数据一致
---
### 94. redis和memcached的区别
1. redis支持多种数据结构，适合存储复杂数据类型
   memcached只支持简单的键值对存储
2. redis支持持久化功能，可以将数据保存在磁盘上
   memcached不支持数据持久化，重启后数据会丢失
3. redis支持主从复制和集群分片，能在分布式环境中提供高可用性
   memcached需要在客户端代码中实现分布式逻辑
4. redis支持lua脚本等特性
   memcached没有这些特性
---
### 95. Redis的hash是什么
是一种键值对集合，可以将多个字段和值存储在同一个键中，便于管理关联数据
特点:
适合存储小数据，使用哈希表实现，能在内存中高效存储
支持快熟的字段操作，适合存储对象属性

---
### 96. Redis跳表的实现原理是什么
跳表通过多层链表实现
- 插入时，首先从最高层开始查找插入位置，然后随机决定新节点层数，在相应层插入节点更新指针
- 删除时，从最高层开始查找需要删除的节点，并在每层更新指针，保持跳表结构
- 查找时，从最高层向下，逐层向下，直到找到目标元素，或者目标元素不存在，效率高
---
### 97. Redis的数据类型有哪些
1. String, 用于缓存临时数据或实现计数器
2. Hash, 键值对集合，适合存储对象
3. List, 有序的字符串集合，用于存储历史记录等
4. Set, 无序不重复字符串集合，用于存储标签
5. Sorted Set, 有序集合，每个元素有一个用于排序的分数，用于排行榜等情况
---
### 98. Redis设计为单线程的原因，6.0版本为何引入多线程
单线程的原因:
1. Redis操作基于内存，大多数性能瓶颈不是CPU导致的
2. 使用单线程模型减少了代码量，减少了线程切换的开销
3. Redis单线程情况下，使用I/O多路复用就可以提高Redis I/O的利用率了

引入多线程原因
数据规模增长，请求量增多，redis的执行瓶颈主要在于网络I/O, 多线程可以提高网络I/O的处理速度

---
### 99. Redis为什么很快
- Redis数据存储在内存中，内存访问比磁盘数据库快的多
- Redis使用单线程驱动模型和I/O多路复用，提高了并发处理速率
- Redis提供了多种高效的数据结构，能够快速完成各种操作
--- 
### 100. MySQL解决深度分页问题
深度分页是指，数据量极大时，分页访问后面的数据，就会大批量扫面前面的数据，增加数据库负载，影响性能
优化方式:
1. 使用子查询和Join进行优化
2. 使用子查询和Id过滤优化
3. 记录上一个ID
---
### 101. 什么时分库分表，分库分表有哪些类型
分库分表是数据库性能优化的一种方法，通过将数据分散存储在多个数据库和表中，提高系统可扩展性、性能、可用性
策略:
1. 水平分表: 将同一张表按行划分，分散到多张表中
2. 垂直分表: 将一张表的不同列拆分到多个表中，减少每张表的字段数量，提高查询效率
3. 水平分库，将相同表结构复制一份到另一个库中，可以减少单一数据库的读写压力
4. 垂直分库，将数据分散到不同数据库实例中，可根据业务功能和模块分库
---
### 102. 如何处理MySQL的主从同步延迟
主从同步延迟无法避免，它本身就是通过binlog从主库同步到从库
解决方法:
- 二次查询，若从库查不到数据，则去主库重新查一遍
- 强制将写入后立马查询的操作转移到主库上
- 关键业务走主库，非关键业务还是读写分离
- 使用缓存，主库写入后同步到缓存，查询可以先查缓存
---
### 103. 什么是MySQL的主从同步机制，如何实现
主从同步机制是一种数据复制技术，将主数据库上的数据同步到一个或多个从数据库中
主要是通过二进制日志binlog实现，主数据库在执行写任务时，会将这些操作记录到binlog中，推送给数据库，从数据库重放对应的日志完成复制

---
### 104. MySQL中如何进行SQL调优
1. 合理设计索引，利用联合索引进行覆盖索引的优化
2. 避免`SELECT *`，只查询必须的字段
3. 避免在SQL中进行函数计算操作，会无法命中索引
4. 避免使用`%LIKE`，导致全表扫描
5. 注意联合索引需要满足最左匹配原则
6. 不要对无索引字段进行排序操作
7. 连表查询需要注意不同字段字符集是否一致，否则会全表扫描
---
### 105. `count(*)`、`count(1)`、`count(字段名)`有什么区别
1. `count(*)`会统计所有行的数量，包括null
2. `count(1)`和`count(*)`功能几乎一样，效率上`count(*)`和`count(1)`一致
3. `count(字段名)`会统计指定字段不为null的行数。对指定字段计数，因此效率比前两个慢
---
### 106. 使用MySQL的EXPLAIN语句进行查询分析
1. 在SQL语句前加上`EXPLAIN`执行
2. 分析输出：
   - select_type: 查询类型
   - table: 查询的数据表
   - type: 访问类型，性能从好到差是const > eq_ref > ref > range > index > ALL
   - key: 实际用到的索引
   - rows: 估计扫描的行数，越小越好
   - Extra: 额外信息
---
### 107. MySQL中发生死锁如何解决
死锁是指在多个并发事务中，彼此之间出现相互等待，导致事务无法继续执行
解决:
- MySQL自带死锁检测机制，当有死锁时，数据库会自动回滚其中一个持有资源少的事务，解除死锁
- MySQL还有锁等待超时的参数，当获取锁的等待时间超过阈值就会释放锁回滚
- 手动找出被阻塞的事务以及进程id，手动kill，释放资源
---
### 108. 乐观锁和悲观锁是什么
1. 悲观锁: 假设会发生冲突，因此在操作数据前对数据加锁，确保其他事务无法访问数据
   使用行级锁或表级锁，`SELECT ... FOR UPDATE`或`LOCK IN SHARE MODE`
2. 乐观锁，假设不发生冲突，因此操作时不加锁，而是更新数据时进行版本控制，发现数据被其他事务修改，则拒绝当前事务修改
   通过每次更新时检查版本号或时间戳是否一致来实现
---
### 109. MySQL中的锁类型
1. 行级锁: 仅对特定的行加锁，允许其他事务访问不同行
2. 表级锁: 对整个表加锁，其他事务无法对该表进行读写操作
3. 共享锁: 允许多个事务并发读取同一资源，但不许修改，只有释放后，其他资源才获得排它锁
4. 排它锁: 只允许一个事务对资源读写，其他事务在获得它之前无法访问资源
5. 间隙锁: 针对索引中两个记录中间的间隙加锁，防止其他事务在间隙中插入数据
6. 临键锁: 行级锁和间隙锁的结合，锁定具体行和其前面的间隙
---
### 110. 数据库的脏读、不可重复读、幻读是什么
1. 脏读: 一个事务读取到另一个事务未提交的数据，若该未提交的事务最终被回滚，那么第一个事务读取的数据就是脏的
2. 不可重复读: 同一事务中，读取同一数据两次，由于其他事务提交，读取结果不同
3. 幻读: 同一事务中，执行相同的查询操作，返回的结果集由于其他事务插入而发生变化
---
### 111. MySQL默认的事务隔离级别是什么，为什么选择这个级别
默认隔离级别是可重复读，即RR
为了兼容早期binlog的statement格式问题，若使用其他隔离级别，使用statement格式的binlog会导致主从数据库数据不一致的问题

---
### 112. MySQL的事务隔离级别有哪些
1. 读未提交: 最低隔离级别，一个事务可以看到另一个事务尚未提交的数据修改，引发脏读
2. 读已提交: 一个事务只能看到自己已经提交的其他事务做的修改，解决了脏读，但会引发不可重复读
3. 可重复读: 确保一个事务中的多个查询返回的结果一致，解决了不可重复读，但会引发幻读问题
4. 串行化: 最高隔离级别，保证事务间的操作相当于一个按顺序执行的单线程操作，可以避免所有并发问题，但消耗性能
---
### 113. MySQL的MVCC是什么？
MVCC是一种并发控制机制，允许多个事务同时读取和写入数据库，无需相互等待，提高了数据库并发性能
MVCC会为每个事务创建数据快照，数据被修改时，不会立刻覆盖，而是生成保留旧版本号和时间戳的新版本记录
多版本时间形成版本链，不同时刻启动的事务可以无锁获得不同版本数据。读写操作都不会阻塞

---
### 114. MySQL长事务会导致哪些问题
1. 长事务持有锁的时间长，容易导致其他事务在尝试获取相同锁时发生堵塞，降低并发性能
2. 长事务更容易引发死锁，多个事务都可能在等待对方释放锁
3. 主库需要长时间执行，然后传输给从库，从库需要长时间重放，数据长时间不同步
4. 如果长事务执行的时间内，报错，事务回滚，之前的执行就浪费了
---
### 115. MySQL如何实现事务
1. 利用锁机制使用数据并发修改的控制，满足事务隔离性
2. RedoLog, 记录事务对数据库的所有修改，若MySQL崩溃，重放Redolog即可恢复数据，满足事务持久性
3. UndoLog, 记录事务反向操作，保存事务历史版本，用于回滚，实现原子性
4. MVCC, 满足了非锁定读的需求，提高了并发度，实现了事务隔离性
---
### 116. MySQL选择使用B+树作为索引结构的原因
1. B+树是一种自平衡树，新增和删除节点时会自平衡，具有高效的查找性能
2. 树的高度增长不会过快，不会像红黑树那样数据越多，高度越高，使得查询磁盘的I/O次数减少
3. 范围查询能力强，叶子节点是使用双向链表连接
---
### 117. 详细叙述MySQL的B+树查询数据的全过程
1. 数据从根节点找起，根据比较键值与节点中存储的索引键值，确定分支，定位叶子节点
2. 叶子节点存储实际的数据行记录，一页16KB，不止一条记录
3. 叶子节点中数据以组的形式划分，利用页目录结构，通过二分查找可以定位到组
4. 定位组后，利用链表遍历即可找到对应数据行
---
### 118. MySQL是不是索引越多越好
不是
1. 索引越多，增删改查时需要修改的地方就越多，时间开销就会变大，B+树还会有页分裂，合并操作，进一步增大时间开销
2. 每建立一个二级索引，都需要建立一个新的B+树，如果数据量很大，索引有很多，会占用空间
---
### 119. 索引一定有效吗？如何排查索引效果
不一定有效，索引最终是否用上是根据MySQL的成本计算决定的，查询条件不包含索引、MySQL对于小表使用全表扫描之类的就无效
排查索引效果，在查询前加上EXPLAIN，观察:
- type: 查询的访问方法，若type的值为ALL，代表查询时全表扫描，没用索引
- key: 查询使用的索引，若为NULL，则索引未生效
- rows: 显示了扫描行数，根据扫描行数评估扫描量
---
### 120. MySQL中索引建立的注意事项
1. 索引不是越多越好，索引会占用空间，每次修改都要维护索引工具消耗资源
2. 有大量重复字段值的不要建立索引，
3. 对于TEXT、LongText长字段不应该建立索引
4. 当数据表的修改频率远大于查询频率时，建立索引会减慢修改效率
5. 对于频繁作为条件查询字段应该建立索引，提高查询效率
6. 在order by、group by后面的字段建立索引，索引可以加快分组、排序操作的速度
---
### 121. MySQL索引下推是什么
一种减少回表查询，提高查询效率的技术。允许MySQL在使用索引查询数据时将条件下推到存储索引层过滤，减少需要从表中读取的数据行

---
### 122. 覆盖索引是什么
MySQL的覆盖索引是指二级索引中包含了查询所需的所有字段，查询可以仅通过访问二级索引而不需要访问实际的表数据。

---
### 123. 回表是什么
回表是使用二级索引作为条件进行查询时，由于二级索引中只存储了索引字段和对应的主键值，无法得到其他数据。
要查询其他数据，要根据主键去聚簇索引查找实际数据行

---
### 124. InnoDB引擎中的聚簇索引和非聚簇索引的区别
1. 聚簇索引: 索引叶子节点存储的是数据行，可以访问完整数据；每个表只能有一个聚簇索引，通常是主键索引
2. 非聚簇索引: 索引叶子节点存储的是主键和对应的索引列，需要主键才能访问完整数据行。
---
### 125. MySQL的索引类型有哪些
数据结构角度:
- B+树索引
- 哈希索引
- 倒排索引
- R-树索引

物理存储角度
- 聚簇索引
- 非聚簇索引

索引性质角度
- 普通索引
- 主键索引
- 联合索引
- 唯一索引
- 全文索引
- 空间索引
---
### 126. MySQL存储引擎有哪些，区别是什么
1. InnoDB
   - 支持事务、行级锁和外键
   - 提供高并发性能
   - 数据以聚集索引的方式存储，提高检索效率
2. MyISAM
   - 不支持事务和外键，使用表级锁
   - 适合读取多，更新少的场景
   - 具有较高的读性能和较快的表级锁定
---
### 127. 描述SQL语句在MySQL的执行过程
1. 先通过连接器校验权限
2. 利用分析器进行SQL语法分析，构建解析树
3. 利用优化器选择合适索引和表连接顺序，选出最佳执行计划
4. 利用执行器，调用引擎层查询数据，返回结果集给客户端
---
### 128. Spring事务传播行为
1. PROPAGATION_REQUIRED(默认) 如果当前存在事务，则用当前事务，如果没有则另起事务
2. PROPAGATION_SUPPORT 支持当前事务，若不存在，则以非事务方式执行
3. PROPAGATION_MANDATORY 支持当前事务，若不存在，抛出异常
4. PROPAGATION_REQUIRES_NEW 创建新事务，若存在当前事务，则挂起当前事务
5. PROPAGATION_NOT_SUPPORTED 不支持当前事务，始终以非事务方式执行
6. PROPAGATION_NEVER 不支持当前事务，若当前存在事务，则抛出异常
7. PROPAGATION_NESTED 当前事务存在，则在嵌套事务中执行，内层事务依赖外层事务，外层失败则回滚内层，内层失败不影响外层
---
### 129. Spring用到的设计模式
1. 工厂模式，BeanFactory,整个Spring IOC就是一个工厂
2. 模板方法，名字是xxxTemplate的都是模板
3. 代理模式，AOP整个都是代理模式
4. 单例模式，Bean默认是单例的
5. 责任链模式，SpringMVC中的多个拦截器串联起来形成责任链
6. 观察者模式，在Spring中的监听器实现
7. 适配器模式，SpringMVC中提到的handlerAdapter就是适配器
---
### 130. Spring Bean的生命周期
1. 实例化: Spring容器根据配置或注解实例化Bean
2. 属性注入: Spring将依赖注入到Bean实例中
3. 初始化前的扩展机制: 检查Bean有没有实现aware接口，有则执行注入
4. 初始化前: 通过BeanPostProcessor接口对Bean进行额外处理
5. 初始化
6. 初始化后，通过BeanPostProcessor进行进一步处理
7. 使用Bean
8. 容器关闭后，通过destroy()方法销毁
---
### 131. 为什么Spring循环依赖需要三级缓存
二级缓存可以解决依赖问题，但涉及到动态代理AOP时，直接使用二级缓存，不做任何处理会导致Bean是未代理的原始对象，如果二级缓存内存放的都是代理对象，就违反了Bean的生命周期

---
### 132. Spring如何解决循环依赖
1. 使用了三级缓存:
   一级缓存用于存储初始化完成的单例Bean
   二级缓存用于尚未初始化，但已经实例化的bean
   三级缓存用于存储对象工厂
2. 解决步骤
   Spring首先创建Bean实例，加入三级缓存
   当一个Bean依赖另一个未初始化的Bean时，Spring从三级缓存中获取bean工厂，生成bean对象
   代理对象存入二级缓存，解决依赖循环
   一旦所有依赖bean被初始化，Bean将转移到一级缓存中
---
### 133. 什么是循环依赖
指多个模块、类、组件之间相互依赖，形成一个闭环。
若模块A依赖于模块B，而模块B又依赖于模块A，会导致依赖链闭环，无法确定加载或初始化的顺序

---
### 134. SpringAOP默认用什么动态代理
SpringFramework默认使用的是JDK动态代理
SpringBoot2.x默认动态代理是CGLIB
区别:
- JDK动态代理: 基于接口实现，用于代理接口的场景，适合代理的类实现了接口
- CGLIB动态代理: 基于类继承，适合没有接口的类，或需要代理类中非接口方法的场景，不能代理final的类和方法
---
### 135. 什么是AOP
AOP，面向切面编程，
核心思想是将与业务逻辑无关的横切关注点抽取出来，通过声明的方式动态应用到业务方法上，而不是将代码直接嵌入业务逻辑，避免重复代码
组成部分: 切面，连接点，通知，切入点，织入

---
### 136. 什么是SpringIOC
Spring IOC是Spring核心框架，通过依赖注入实现
核心思想是将对象的创建和依赖关系交由Spring容器管理，而不是由代码控制。使得程序更加灵活和解耦，提升了代码可维护性和扩展性。
依赖注入: 通过构造器注入、setter注入或接口注入, 将对象所需的依赖传递给它，而不是让对象自行创建依赖

---
### 137. Spring有哪些重要模块组成
- Spring Core: 提供了依赖注入和控制反转实现，Spring模块的基础
- Spring AOP: 提供了面向切面编程的功能，可以在方法执行前后插入额外的日志记录逻辑等
- Spring JDBC: 简化了原生JDBC操作
- Spring MVC: 实现了MVC框架，用于构建HTTP请求的Web应用
- Spring ORM: 支持与主流ORM框架(Mybatis)的集成, 简化持久层开发

---
### 138. JVM常见的配置参数
- -Xms: 初始化堆内存大小
- -Xmx: 最大堆内存大小
- -Xss: 设置每个线程的栈大小
- -XX:MetaspaceSize: 初始元空间大小
- -XX:MaxMetaspaceSize: 最大元空间大小
- -XX:+HeapDumpOnOutOfMemoryError: 当发生OOM时，生成堆转储
- -XX:+PrintGCDetails: 打印垃圾回收日志
- -XX:+UseG1GC: 启用G1垃圾收集器
- -XX:+UseConcMarkSweepGC: 启动CMS垃圾收集器
- -XX:+UseZGC: 启用ZGC低延迟垃圾收集器
---
### 139. 如何对Java的垃圾回收进行调优
1. 合理配置堆内存大小、调整新生代和老年代比例；
2. 调整垃圾回收阈值，优化回收的频率和时机；
3. 避免频繁Full GC, 减少长时间停顿。
---
### 140. JVM垃圾回收调优的主要目标是什么
1. 垃圾回收调优首要目标是减少程序停顿时间，确保垃圾回收过程中保持应用响应能力
2. 第二个目标是提高应用吞吐量，即在单位时间内完成更多的业务处理，通过合理GC策略配置，减少GC频率和时间，提升性能
---
### 141. Java中的垃圾回收算法
1. 标记清除算法
   - 首先遍历堆的对象，标记所有存活对象，清除未标记对象
   - 实现简单，但标记和清除会产生内存碎片，影响内存分配效率
2. 标记整理算法
   - 标记所有存活的对象，存活的对象整理到一边，清除未标记对象
   - 解决了内存碎片问题，但整理过程中需要移动对象，造成额外开销
3. 复制算法:
   - 将内存分成两份，每次使用其中一半，垃圾回收时，将存活对象从一半复制到另一半，清除原区域的所有对象
   - 无需处理内存碎片，分配效率高；但需要双倍内存空间，浪费了一半空间
---
### 142. 为什么Java8移除了永久代并引入元空间
主要是为了解决PermGen固定大小、容易内存溢出、GC效率低的问题。
元空间使用本地内存，具备灵活分配能力，提升了垃圾收集和内存管理效率

---
### 143. Java中常见的垃圾收集器
1. Serial GC: 单线程收集器，适合小型应用和单处理器环境
2. Parallel GC: 利用多线程进行垃圾回收
3. CMS GC: 通过并发执行标记和清理来减少停顿时间，但会产生内存碎片
4. G1 GC: 将堆划分为多个区域，优先回收堆垃圾最多的区域
5. ZGC: 低延迟垃圾回收器，能处理大内存和高并发的场景
---
### 144. JVM内存区域划分
1. 方法区: 存储类信息、常量、静态变量
2. 堆: 存放所有线程共享的对象和数组，垃圾回收的主要区域
3. 虚拟机栈: 每个线程创造一个栈，用来保存局部变量、操作数栈等
4. 本地方法栈: 本地的代码在这分配内存
5. 程序计数器: 保存当前线程执行的字节码指令的地址或行号
---
### 145. 编译执行和解释执行的区别
1. 编译执行: 程序在执行前，首先通过编译器将代码编译为机器码，然后在CPU上直接运行。编译后运行速度快，但跨平台性差，编译后的机器码难调试或逆向
2. 解释执行: 解释执行是源代码在运行时通过解释器逐行翻译并执行。跨平台性好，开发周期短，运行速度慢
3. JVM是二者结合
   - JVM会逐行解释执行字节码，有助于跨平台性
   - JVM引入了即使编译器，在程序运行时将热代码编译为本地机器码，提升性能
---
### 146. Java的ABA问题
ABA是指在多线程环境下，某变量的值在一段时间内经历了从A到B再到A的变化，可能会被线程误认为无变化，导致错误的判断和操作。会发生在CAS操作的无锁并发编程中

---
### 147. Java中的volatile关键字作用是什么
1. 可以确保变量的可见性。当线程修改了volatile变量值，会立刻刷新在主内存，其他线程在读取该变量时立即获取新值。避免缓存一致性问题
2. 禁止指令重排序，保证程序的执行顺序符合预期。
---
### 148. 避免死锁的方法
1. 死锁必要条件:
   - 互斥条件: 每个资源只被一个线程占用
   - 占有和等待: 线程在持有至少一个资源时等待获取其他资源
   - 不可抢占: 线程获得的资源在未使用完毕前不能被其他资源抢占
   - 循环等待: 多线程形成头尾相接循环等待资源关系
2. 避免办法
   - 固定资源申请顺序
   - 缩小锁的范围
   - 使用支持超时的办法获取锁
   - 避免嵌套锁
---
### 149. 为什么Java的ThreadLoad对key的引用为弱引用
可以防止内存泄漏。若ThreadLoad实例被不再需要的线程持有为强引用，那么线程结束，相关ThreadLoad实例及其对应数据可能无法回收，导致内存持续占用。而弱引用允许垃圾回收器在内存不足时回收对象。

---
### 150. Java的final关键字能否保证变量可见性
对于final修饰的变量，构造方法执行完毕后，线程一定能看到正确的final变量值
但若final变量指向的是可变对象，那么final仅能保证引用的可见性，不能保证对象内部状态可见性
如果要保证对象内部状态可见性，需要用volatile或synchronized

---
### 151. 什么是Java的原子性、可见性、有序性
1. 原子性指的是一个操作或一系列操作要么全部执行成功，要么全部不执行
2. 可见性指当一个线程修改了某个共享变量的值，其他线程能够立即看到修改
3. 有序性指程序执行顺序和代码先后顺序一致，多线程环境中，编译器和处理器可能对指令重排序
---
### 152. 什么是Java内存模型JMM
JMM是JVM中的一种规范，用于描述多线程程序中变量如何在内存中存储和传递的规则，规范了线程何时从主内存中读取数据，何时把数据写回主内存
核心目标是保证多线程环境下的可见性、有序性、原子性。

---
### 153. 什么是Java的CAS操作
一种硬性级别的原子操作，它比较内存中的某值是否为预期值，是则更新为新值，否则不做修改
原理:
- CAS会比较内存中某值是否与预期值相等
- 如果相等，则将内存中的值更新为新值
- 若不相等，说明其他线程将值更改，CAS操作失败，一般会利用重试，直到成功
---
### 154. 谈一下AQS
AQS起到了一个抽象封装的作用。将一些排队、入队、加锁、中断的方法提供出来，便于其他相关JUC锁的使用，具体加锁、入队时机等需要实现类控制。
通过维护一个共享状态(state)和一个先进先出的队列等待，管理线程对共享资源的访问
state用volatile修饰，表示当前资源状态。
当线程尝试获取资源失败时，会被加入到AQS队列中。

---
### 155. 优化Java中锁的使用
1. 缩小锁的范围，减少锁的持有时间，在必要的最小代码块用锁
2. 用细粒度的锁，将大对象锁拆分为小对象锁，提高并行度
3. 对于读多写少的场景，可以使用读写锁
4. 减少锁的使用，通过减少对共享资源的使用，避免对同一个资源的竞争
---
### 156. Java的synchronized如何实现
依赖于JVM的监视器锁和对象头
当`synchronized`修饰在方法或代码块上，对特定的对象和类加锁，从而确保同一时刻只有一个线程执行加锁的代码块
- 修饰方法时，会在访问标识中加上ACC_SYNCHRONIZED标识，每当线程访问该方法检查到包含该标志时，就必须先获得方法对应对象的监视器锁，才能继续执行该方法
- 修饰代码块时，会在代码前后插入`monitorenter`和`monitorexit`字节码指令，前者为加锁，后者为解锁。
---
### 157. Synchronized和ReentrantLock有什么区别
1. `Synchronized`是java内置关键字，实现基本同步机制，不支持超时，非公平，不可中断，不支持多条件
2. `ReentrantLock`是JUC库提供的，支持设置超时时间，可以避免死锁，比较灵活，支持公平锁，可中断，支持多条件判断
3. `ReentrantLock`需要手动解锁，`Synchronized`不需要，它们都是可重入锁
---
### 158. 使用过哪些Java并发工具类
1. `ConcurrentHashMap`
   是一个线程安全且高效的哈希表，支持并发访问，进行读写操作，不会导致线程安全问题
2. `AtomicInteger`
   提供一种线程安全的方法对int进行原子操作
3. `Semaphore`
   控制访问资源的线程数，可以用来实现限流或访问控制
4. `CyclicBarrier`
   允许线程在某个同步点等待，适合分阶段执行任务
5. `CountDownLatch`
   一个或多个线程等待其他线程执行，适合主线程等子线程
6. `BlockingQueue`
   线程安全的阻塞队列，用于实现生产者-消费者模式
---
### 159. Java线程池有哪些拒绝策略
1. AbortPolicy，任务队列满且没有添加任务时，会直接抛出错误，默认策略
2. CallerRunsPolicy，当任务队列满且没有线程空间，会添加任务由调用者线程执行
3. DiscardOldestPolicy，当任务队列满没有线程空间，会删除最早的任务，重新提交当前任务
4. DiscardPolicy，直接丢弃当前提交的任务，不会执行任何操作，也不抛出异常。
---
### 160. 如何合理设置Java线程池的线程数
1. CPU密集型任务
   不涉及I/O操作，可以充分利用CPU资源，不会因为I/O操作被阻塞，不需要很多线程。
   理论上CPU密集型线程数 = CPU核心数 + 1。
2. I/O密集型任务
   有很多I/O操作，任务在读取这些数据时，无法利用CPU，对应线程就会被阻塞等待I/O完成，因此就需要更多线程。
   理论上I/O密集型任务线程数 = CPU核心数 * 2
---
### 161. 线程池的原理
线程池是一种池化技术，预先创建并管理一组线程，避免频繁创建和销毁线程的开销，提升性能
原理:
1. 默认情况下不会预创建，任务提交后才能创建线程
2. 线程满了后不会新建线程，而是把任务堆积到工作队列中
3. 工作队列放不下，才会新增线程，直至达到最大线程数
4. 队列满了，达到最大线程数了，这时任务会执行拒绝策略
5. 如果线程空闲时间超出存活时间，并且当前线程数大于核心线程数则会销毁线程，直到线程数等于核心线程数
---
### 162. 线程生命周期在Java中如何定义
1. New 初始状态，线程创建后，未调用start()方法
2. Runnable 可运行状态，调用start()方法后，线程就绪，等待CPU调度
3. Blocked 阻塞状态，线程试图获取对象被阻塞
4. Waiting 等待状态，线程进入等待状态，需要被显式唤醒才能继续执行
5. Timed Waiting 含等待时间的等待状态，线程进入等待状态，但有等待时间，超时就会被唤醒
6. Terminated 终止状态，线程执行完毕或因异常退出
---
### 163. 线程和进程区别
1. 进程: 资源分配的基本单位，每个进程有自己独立的内存空间，每个进程相互独立
2. 线程: 属于进程，一个进程内部可以包含多个线程，线程共享进程的资源，内存空间，但每个线程有自己的栈和寄存器
3. 进程需要为其分配独立的内存空间和系统资源，创建和切换进程开销大；
   线程共享进程资源，创建和切换的开销远小于进程
4. 进程因为独立的内存空间，进程的通信较为复杂，要使用管道，消息队列，共享内存等方式
   同一进程内线程共享内存空间，因此线程可以直接读写内存
---
### 164. Java中ConcurrentHashMap 1.7和1.8之间的区别
1. 1.7版本中，ConcurrentHashMap采用分段锁，每个Segment独立，默认有16个，可并发访问，因此可以同时并发执行16个线程
   1.8版本移除了`Segment`，锁的粒度细化，通过CAS进行插入操作，只有在更新链表或红黑树才用synchronized，并发度增加
2. JDK1.7 ConcurrentHashMap只是用了数组和链表的结构，而JDK1.8引入了红黑树
---
### 165. Java1.8对HashMap除了红黑树，还进行了哪些改动
1. 改进了哈希函数的计算，使得哈希值分布更均匀，减少了哈希冲突的发生
2. 改进了扩容时的元素迁移机制，在扩容过程中不再重新计算哈希值，而是根据原数组长度的高位判断元素是否迁移，减少了不必要的计算
3. 头插法改为了尾插法，避免了并发情况下成环的概率
---
### 166. 为什么JDK1.8对HashMap进行了红黑树的改动
Java1.8 前，HashMap用链表解决哈希冲突。当哈希冲突多时，链表中元素增多，查找、插入、删除的时间复杂度退化。
引入红黑树，当链表长度超出阈值就会将链表转为红黑树，避免性能急剧下降。
当链表长度下降为6后，红黑树重新退化成链表，保持简单高效

---
### 167. 为什么Java中HashMap的默认负载因子是0.75
为了能够在时间复杂度和空间复杂度上取得一个平衡，负载因子在0.75时，避免了过多扩容，还保证了不会出现过多的哈希冲突，确保查找和插入操作的效率，维持良好的性能表现

---
### 168. 为什么HashMap在Java扩容时采用2的n次方倍
为了提高hash的分布均匀性和哈希计算的概率
1. 当容量为2的n次方倍时，哈希码的地位对索引影响更大，哈希值分布更均匀，减少哈希冲突
2. HashMap使用(n-1) & hash来计算索引，位运算效率高于取模运算，提高了哈希计算效率
3. 简化扩容过程，扩容容量为2的n次方，只需通过简单位运算就能判断是否需要迁移，减少开销
---
### 169. Java的HashMap扩容机制是怎样的
HashMap的扩容是基于负载因子来决定的，默认情况下，负载因子为0.75，当已存储元素超过当前容量75%时就会触发扩容操作
触发扩容时，HashMap容量会扩大到当前容量2倍
扩容时，HashMap所有元素重新分配到新的哈希桶中，根据新的容量大小重新计算位置，移动到新数组中

---
### 170. 数组和链表在Java中的区别是什么
1. 数组是内存中的连续空间，链表可以不连续
2. 数组固定长度，需要扩容，则需要重新开辟空间，链表可以直接用指针指向不同地址，扩展方便
3. 读取多的场景下适合用数组，数组可以用下表访问空间，插入和删除操作多时可以用链表
4. 链表需要额外的空间存储指针，占用空间多
---
### 171. Java中有哪些集合类
1. List接口
   - ArrayList: 基于动态数组，查询速度快，插入、删除慢
   - LinkedList: 基于双向链表，插入删除快，查询速度慢
   - Vector: 线程安全动态数组，类似于ArrayList，但开销大
2. Set接口
   - HashSet: 基于哈希表，元素无序，不允许重复
   - LinkedHashSet: 基于链表和哈希表，维护插入顺序，不允许重复
   - TreeSet: 基于红黑树，元素有序，不允许重复
3. Queue接口
   - PriorityQueue: 基于优先级堆，元素按照自然顺序或指定比较器排序
   - LinkedList: 作为队列使用，支持先进先出操作
4. Map接口
   - HashMap: 基于哈希表，键值对无序，不重复
   - LinkedHashMap: 基于链表和哈希表，维护插入顺序，不允许键重复
   - TreeMap: 基于红黑树，键值对有序，不允许键重复
   - HashTable: 线程安全的哈希表，不允许键和值为null
   - ConcurrentHashMap: 线程安全哈希表，适合高并发场景，不允许键和值为null
---
### 172. 设计一个点赞功能
1. 点赞请求首先写入Redis，快速响应给用户，实时生效
2. 点赞操作通过消息队列写入后台任务
   后台任务定期将Redis数据同步到MySQL，确保持久化存储
3. 点赞状态和技术优先从Redis读取，未命中时再从MySQL加载。
---
### 173. 什么是Mybatis-Plus，什么作用，什么区别
Mybatis-Plus是Mybatis的增强版框架，二次封装，只做增强不做改变。
提供了条件构造器，可以通过代码形式构建查询条件无需手写SQL语句
提供了分页查询无需手写分页逻辑
提供了代码生成工具，可以根据数据库表自动生成实体类、mapper和xml映射文件

---
### 174. 什么是Elasticsearch, 什么优势和场景
1. Elasticsearch是一个分布式搜索引擎以及分析引擎，擅长处理大规模数据并且能够在接近实时的情况下提供快速搜索能力。
   由Apache Lucene构建，用于全文本搜索、结构化搜索以及二者结合的复杂搜索
2. 优势:
   速度快: 基于Lucene构建，执行查询时非常快速
   扩展性强: Elasticsearch是分布式的，能轻松增加节点扩展集群应对更大数据
   高可用性: 通过集群方式部署，支持数据的分片和复制，某个节点失效不影响整体运行
   多类型搜索分析: 支持对数据进行多维度的复杂查询
3. 应用场景:
   网站搜索
   日志分析
   数据分析
   实施业务监控
4. 倒排索引机制
   - 本质上是词到文档的映射索引，类似于书本末尾的索引
   - 和传统数据库的正排索引不同，正排索引是通过ID来查看内容，倒排索引是通过关键词找ID列表
   - 过程:
     先将文档分词，为每个不重复的词建立记录，记录中包含这个词的文档id列表，当用户搜索时，系统无需扫描整个文档，直接查找相关词项，就能立刻得到包含它的所有文档id，效率很高
5. 分布式检索机制:
   - 当数据量过大，单个节点无法存下整个索引，就需要分布式检索
   - 将海量数据拆分成多个分片，分布到不同的服务器节点上，每个分片就是完整的、独立工作的索引
   - 当搜索请求到来时，就会同时发送到所有相关分片上，每个分片在本地执行搜索，最后将结果汇总返回给用户
   - 实现类数据水平扩展，可以容纳PB级数据，利用并行计算，大大提升了检索速度
---
### 175. 什么是Docker？为什么要在项目中使用docker？以及项目中如何使用docker
Docker是一种容器化技术，起源于Linux容器服务，可以把应用启动时需要的运行环境一并打包，然后在其他支持docker的服务器上启动。
使用docker是为了快速构建、分享、部署应用，让开发者专注于业务开发，免受环境问题困扰，防止应用影响宿主机
项目中使用docker，是通过Dockerfile将开发的应用构建成Docker镜像，然后上传至docker仓库，在需要部署的服务器上，拉取docker镜像，然后绑定容器卷和ip映射启动，出现问题时，可以使用docker logs查看对应日志定位问题

---
### 176. Docker的基本概念和工作原理
Docker是一种开源的容器化平台，允许开发者和运维人员以一致的方式部署应用程序。
Docker提供了一种便捷的方式执行和移动应用程序。
这种容器在任何服务和所需条件的环境中都能保持一致

原理:
docker利用linux容器技术，通过镜像，容器，仓库等概念实现生命周期管理
首先创建一个docker镜像，镜像是一个只读模板，包含应用程序及其运行所需的所有文件，然后基于镜像，docker可以启动一个或多个容器，容器是镜像的运行实例。

镜像: Docker的核心组件，包含应用程序，所需运行库，以及配置文件
容器: 是镜像的运行实例，容器中可以运行一个或多个镜像，容器独立，有自己的文件系统、cpu、内存等
仓库: 用来存储镜像的地方，类似于代码的版本控制系统，Docker Hub是最常用的公共镜像仓库
Dockerfile: dockerfile是一个包含一系列命令和指令的文本文件，用于自动化构建Docker镜像
Docker网络和存储: 通过自定义网络配置，可以实现不同容器之间的通信隔离；通过卷，可以实现对持久化数据的存储和管理

---
### 177. Docker Compose的主要用途是什么
Docker Compose是用于定义和运行多个容器Docker应用程序的工具。
Compose用YAML文件定义服务、网络和卷，通过`docker-compose up`就能启动并运行整个配置的运行环境